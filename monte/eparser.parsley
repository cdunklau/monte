EOL = tok('EOL')
EOLs = EOL+
br = EOL*

string = tok('.String.')
character = tok('.char.'):c -> t.Character(c)
float = tok('.float64.')
integer = tok('.int.')

identifier = tok('IDENTIFIER')
uriGetter = tok('URI_GETTER'):s -> t.URIGetter(s)
uri = tok('URI'):u -> t.URIExpr(*u.split(':', 1))

literal = (string | character | float | integer):x -> t.LiteralExpr(x)

noun = sourceHole | justNoun
justNoun = ((identifier:id -> self.keywordCheck(id)
              | ("::" (string | identifier):x -> x)):n  -> t.NounExpr(n)
              | uriGetter)
sourceHole = ('${' integer:i '}' -> t.QuasiLiteralExpr(i)
             |'@{' integer:i '}' -> t.QuasiPatternExpr(i))

quasiString = subquasi*:qs 'QUASI_CLOSE':qc -> qs + [t.QuasiText(qc)]
subquasi = ('QUASI_OPEN':q -> t.QuasiText(q)
           |'${' seq:e '}' -> t.QuasiExprHole(e)
           |'_' !(noIgnoreExpressionHole())
           |'DOLLAR_IDENT':id -> t.QuasiExprHole(t.NounExpr(id))
           |'@{' br pattern:s '}' -> t.QuasiPatternHole(s)
           |"AT_IDENT":id -> t.QuasiPatternHole(t.FinalPattern(t.NounExpr(id), None)))

reifyExpr = ("&&" verb:v -> t.BindingExpr(v)
            |"&" verb:v -> t.SlotExpr(v))

verb = identifier | string

listAndMap = "[" (assoc:x ("," assoc)*:xs ","? ']' -> t.MapExpr([x] + xs)
                   |(seq:s ("," seq)*:ss ","? ']')-> t.ListExpr([s] + ss)
                   | ']' -> t.ListExpr([]))
assoc = (seq:k "=>" seq:v -> t.MapExprAssoc(k, v)
          |"=>" (noun | reifyExpr):n -> t.MapExprExport(n)
                | "def" noun:n ~":="
                  !(throwSemanticHere("Reserved syntax: forward export")))


prim = ( literal
         | basic
         | identifier?:n quasiString:qs -> t.QuasiExpr(n, qs)
         | noun
         | uri
         | parenExpr:p (quasiString:qs -> t.QuasiExpr(p, qs)
                         | -> p)
         | block:b -> t.HideExpr(b)
         | listAndMap
         )

parenExpr = "(" seq:s ')' -> s
block = "{" (seq |-> t.SeqExpr([])):s '}' -> s

seqSep = (";"| tok('EOL'))+
seq = expr:e ((seqSep expr)+:es seqSep? -> t.SeqExpr(filter(None, [e] + es))
                 |seqSep? -> e)
parenArgs = "(" args:a ')' -> a
args = (seq:s ("," seq)*:ss -> [s] + ss
         |-> [])

call = (call:c ("." verb:v (parenArgs:x -> t.MethodCallExpr(c, v, x)
                                  | -> t.VerbCurryExpr(c, v))
                    |"[" args:a ']' -> t.GetExpr(c, a)
                    |parenArgs:x -> t.FunctionCallExpr(c, x)
                    | "<-" (parenArgs:x -> t.FunctionSendExpr(c, x)
                           |verb:v (parenArgs:x -> t.MethodSendExpr(c, v, x)
                                     | -> t.SendCurryExpr(c, v)))
                    )
         |prim
         )

prefix = (call
           | "-" call:c -> t.Minus(c)
           | "!" call:c -> t.LogicalNot(c)
           | "~" call:c -> t.BinaryNot(c)
           | reifyExpr
           | "&" call !(throwSemanticHere("reserved: unary prefix '&' applied to non-noun lValue")))

pow = prefix:x ("**" prefix:y -> t.Pow(x, y)
                   | -> x)
mult = (mult:x ("*" pow:y -> t.Multiply(x, y)
                 |"/" pow:y -> t.Divide(x, y)
                 |"//" pow:y -> t.FloorDivide(x, y)
                 |"%" pow:y -> t.Remainder(x, y)
                 |"%%" pow:y -> t.Mod(x, y))
         |pow)

add = (add:x ("+" mult:y -> t.Add(x, y)
                 |"-" mult:y -> t.Subtract(x, y))
        | mult)

shift = (shift:x ("<<" add:y -> t.ShiftLeft(x, y)
                     |">>" add:y -> t.ShiftRight(x, y))
          |add)

interval = shift:x ("..!" shift:y -> t.Till(x, y)
                       |".." shift:y -> t.Thru(x, y)
                       | -> x)

order = interval:x (">" interval:y -> t.GreaterThan(x, y)
                       | ">=" interval:y -> t.GreaterThanEqual(x, y)
                       | "<=>" interval:y -> t.AsBigAs(x, y)
                       | "<=" interval:y -> t.LessThanEqual(x, y)
                       | "<" interval:y -> t.LessThan(x, y)
                       | ":" guard:g -> t.Coerce(x, g)
                       | -> x)

logical = (band
            |bor
            |(order:x ("=~" pattern:p -> t.MatchBind(x, p)
                        |"!~" pattern:p -> t.Mismatch(x, p)
                        |"==" order:y -> t.Same(x, y)
                        |"!=" order:y -> t.NotSame(x, y)
                        |"&!" order:y -> t.ButNot(x, y)
                        |"^" order:y -> t.BinaryXor(x, y)
                        | -> x)))

band = (band:x ~("&&" | "&!") "&" order:y -> t.BinaryAnd(x, y)
         |order:x ~("&&" | "&!") "&" order:y -> t.BinaryAnd(x, y))

bor = (bor:x "|" order:y -> t.BinaryOr(x, y)
        |order:x "|" order:y -> t.BinaryOr(x, y))

condAnd = logical:x (("&&" condAnd):y -> t.LogicalAnd(x, y)
                        | -> x)
cond = condAnd:x (("||" cond):y -> t.LogicalOr(x, y)
                     | -> x)
assign = (~objectExpr "def" (pattern:p ("exit" order)?:e ":=" assign:a -> t.Def(p, e, a)
                  |noun:n (~~seqSep | end)-> t.Forward(n))
           |keywordPattern:p ":=" assign:a -> t.Def(p, None, a)
           |cond:x (":=" assign:y -> t.Assign(x, y)
                    |assignOp:o assign:y -> t.AugAssign(o, x, y)
                    |tok('VERB_ASSIGN'):v (parenArgs:y -> t.VerbAssign(v, x, y)
                                          |assign:y -> t.VerbAssign(v, x, [y]))
                    | -> x))

assignOp = ("+=" -> "Add"
             |"-=" -> "Subtract"
             |"*=" -> "Multiply"
             |"/=" -> "Divide"
             |"%=" -> "Remainder"
             |"%%=" -> "Mod"
             |"**=" -> "Pow"
             |"//=" -> "FloorDivide"
             |">>=" -> "ShiftRight"
             |"<<=" -> "ShiftLeft"
             |"&=" -> "BinaryAnd"
             |"|=" -> "BinaryOr"
             |"^=" -> "BinaryXor")

expr =  assign | ejector
ejector = ('break' -> t.Break
             | 'continue' -> t.Continue
             | 'return' -> t.Return):ej
             (("(" ')' -> None) | assign)?:val -> ej(val)

guard = (noun | parenExpr):e ("[" args:x ']' -> x)*:xs -> t.Guard(e, xs)
optGuard = (":" guard)?
eqPattern = ('_' optGuard:e -> t.IgnorePattern(e)
              |identifier?:n quasiString:q -> t.QuasiPattern(n, q)
              |namePattern
              |"==" prim:p -> t.SamePattern(p)
              |"!=" prim:p -> throwSemanticHere("reserved: not-same pattern")
              )

patterns = (pattern:p ("," pattern)*:ps -> [p] + ps
             | -> [])
key = (parenExpr | literal):x br -> x

keywordPattern = ('var' noun:n optGuard:g -> t.VarPattern(n, g)
                   |'bind' noun:n optGuard:g -> t.BindPattern(n, g))
namePattern = (keywordPattern
              |noun:n optGuard:g -> t.FinalPattern(n, g)
              |reifyPattern)

reifyPattern = ("&&" noun:n optGuard:g -> t.BindingPattern(n, g)
               |"&" noun:n optGuard:g -> t.SlotPattern(n, g))

mapPatternAddressing = (key:k "=>" pattern:v -> t.MapPatternAssoc(k, v)
                         |"=>" namePattern:p -> t.MapPatternImport(p))

mapPattern = mapPatternAddressing:a (":=" order:d -> t.MapPatternOptional(a, d)
                                        | -> t.MapPatternRequired(a))
mapPatts = mapPattern:m ("," mapPattern)*:ms -> [m] + ms

listPatternInner = (mapPatts:ms br ']' ("|" listPattern)?:tail -> t.MapPattern(ms, tail)
                     |patterns:ps br ']' ("+" listPattern)?:tail -> t.ListPattern(ps, tail))
listPattern = (
                "via" parenExpr:e listPattern:p -> t.ViaPattern(e, p)
                | eqPattern
                | "[" listPatternInner)
pattern = listPattern:p ("?" order:e -> t.SuchThatPattern(p, e)
                            | -> p)

basic = docoDef | accumExpr | escapeExpr | forExpr | ifExpr | lambdaExpr | metaExpr | switchExpr | tryExpr | whileExpr | whenExpr

docoDef = br doco?:doc (objectExpr:o -> t.Object(doc, *o)
                       |interfaceExpr:i -> t.Interface(doc, *i))
doco = tok('DOC_COMMENT'):doc br -> doc.strip()
objectExpr = (('def' objectName:n) | keywordPattern:n) objectTail:tail -> [n, tail]
objectName = ('_' optGuard:e -> t.IgnorePattern(e)
               |namePattern)
objectTail = (functionTail
               |(('extends' br order)?:e oAs?:g oImplements:oi scriptPair:s
                  -> t.Script(e, g, oi, *s)))
oAs = 'as' br order
oImplements = ('implements' br order:x ("," order)*:xs -> [x] + xs
               | -> [])
functionTail = parenParamList:ps optResultGuard:g oImplements:fi block:b -> t.Function(ps, g, fi, b)
parenParamList = "(" (pattern:p ("," pattern)*:ps ')' -> [p] +  ps
                       | ')' -> [])
optResultGuard = (":" guard)?
scriptPair = "{" method*:methods matcher*:matchers br '}' -> [methods, matchers]
method = br (doco?:doc (("to" -> t.To) | "method" -> t.Method):to verb?:v parenParamList:ps optResultGuard:g block:b  -> to(doc, v, ps, g, b))
matcher = 'match' pattern:p block:b -> t.Matcher(p, b)

interfaceExpr = ('interface' objectName:n iguards?:g ((multiExtends:es oImplements:oi iscript:s -> [n, g, es, oi, s])
                       |parenParamDescList:ps optGuard:rg -> [n, g, [], [], t.InterfaceFunction(ps, rg)]))
iguards = 'guards' pattern
multiExtends = (('extends' br order:x ("," order)*:xs -> [x] + xs)
                 | -> [])
iscript = "{" (messageDesc:m br -> m)*:ms '}' -> ms
messageDesc = br (doco?:doc ("to" | "method"):to verb?:v parenParamDescList:ps optGuard:g
                -> t.MessageDesc(doc, to, v, ps, g))
paramDesc = (justNoun | ('_') -> None):n optGuard:g -> t.ParamDesc(n, g)
parenParamDescList = "(" paramDesc:p ("," paramDesc)*:ps ')' -> [p] +  ps

accumExpr = 'accum' call:c accumulator:a -> t.Accum(c, a)
accumulator = ((('for' forPattern:p 'in' logical:a accumBody:b catcher?:c -> t.AccumFor(*(p + [a, b, c]))))
                |('if' parenExpr:e accumBody:a -> t.AccumIf(e, a))
                |('while' parenExpr:e accumBody:a catcher?:c -> t.AccumWhile(e, a, c)))

accumBody = "{" ('_' (accumOp:op assign:a -> t.AccumOp(op, a)
                               |"." verb:v parenArgs:ps -> t.AccumCall(v, ps))
                  | accumulator):ab br '}' -> ab
accumOp = ("+" -> "Add"
            |"*" -> "Multiply"
            |"&" -> "BinaryAnd"
            |"|" -> "BinaryOr")

escapeExpr = 'escape' pattern:p block:b catcher?:c -> t.Escape(p, b, c)

forExpr = 'for' forPattern:p 'in' br assign:a block:b catcher?:c -> t.For(*(p + [a, b, c]))

forPattern = pattern:p (br "=>" pattern:px -> [p, px]
                           | -> [None, p])

ifExpr = 'if' parenExpr:p br block:b ('else' (ifExpr | block) | -> None):e -> t.If(p, b, e)

lambdaExpr = br doco?:doc 'fn' patterns:ps block:b -> t.Lambda(doc, ps, b)

metaExpr = 'meta' "." identifier:i (?(i == 'getState') -> "State"
                                   |?(i == 'scope') -> "Scope"
                                   |?(i == 'context') -> "Context"):s "(" ')' -> t.Meta(s)
switchExpr = 'switch' parenExpr:e "{" (matcher:m br -> m)*:ms '}' -> t.Switch(e, ms)

tryExpr = 'try' block:tb catcher*:cs ('finally' block)?:fb -> t.Try(tb, cs, fb)
catcher = 'catch' pattern:p block:b -> t.Catch(p, b)

whileExpr = 'while' parenExpr:e block:b catcher?:c -> t.While(e, b, c)

whenExpr = 'when' parenArgs:a br "->" block:b catcher*:cs ('finally' block)?:fb -> t.When(a, b, cs, fb)

topSeq = topExpr:x (seqSep topExpr)*:xs seqSep? -> t.SeqExpr([x] + xs)
pragma = 'pragma' "." verb:v "(" string:s ')' -> t.Pragma(v, s)
topExpr = (pragma -> t.NounExpr("null")) | expr
start = br topSeq?
