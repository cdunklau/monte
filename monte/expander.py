from ometa.grammar import TreeTransformerGrammar
from ometa.runtime import TreeTransformerBase, ParseError
from terml.nodes import Tag, Term, termMaker as t
### XXX TODO: Create TemporaryExprs for variables generated by
### expansion. Replace all temps with nouns in a single pass at the
### end.

TRUE = Term(Tag('true'), None, None, None)
FALSE = Term(Tag('false'), None, None, None)

class ScopeSet(object):
    def __init__(self, bits=()):
        self.contents = list(bits)[:]

    def __sub__(self, other):
        bits = self.contents[:]
        for bit in other:
            if bit in bits:
                bits[bits.index(bit)] = bits[-1]
                del bits[-1]
        return ScopeSet(bits)

    def __and__(self, other):
        if len(self) > len(other):
            big = self.contents
            small = list(other)
        else:
            small = self.contents
            big = list(other)
        bits = []
        for bit in small:
            if bit in big:
                bits.append(bit)
        return ScopeSet(bits)

    def __or__(self, other):
        bits = list(other)
        for bit in self.contents:
            if bit not in bits:
                bits.append(bit)
        return ScopeSet(bits)

    def getKeys(self):
        return self.contents[:]

    def __iter__(self):
        return iter(self.contents)

    def __len__(self):
        return len(self.contents)

class StaticScope(object):
    def __init__(self, namesRead=None, namesSet=None, metaStateExprFlag=False,
                 defNames=None, varNames=None):
        if namesRead is None:
            namesRead = ScopeSet()
        if namesSet is None:
            namesSet = ScopeSet()
        if defNames is None:
            defNames = ScopeSet()
        if varNames is None:
            varNames = ScopeSet()
        self.namesRead = ScopeSet(namesRead)
        self.namesSet = ScopeSet(namesSet)
        self.defNames = ScopeSet(defNames)
        self.varNames = ScopeSet(varNames)
        self.metaStateExprFlag = metaStateExprFlag

    def hide(self):
        return StaticScope(self.namesRead, self.namesSet,
                           self.metaStateExprFlag,
                           None, None)
    def add(self, right):
        """
        For processing normal expressions left to right, where all definitions
        are exported, but uses are hidden by definitions to their left.
        """
        if right is None:
            return self
        rightNamesRead = (right.namesRead - self.defNames) - self.varNames
        rightNamesSet = (right.namesSet - self.varNames)
        badAssigns = rightNamesSet & self.defNames
        #XXX slavishly porting Java code etc
        if (1 <= len(badAssigns)):
            rightNamesSet = rightNamesSet - badAssigns

        return StaticScope(self.namesRead | rightNamesRead,
                           self.namesSet | rightNamesSet,
                           self.metaStateExprFlag or right.metaStateExprFlag,
                           self.defNames | right.defNames,
                           self.varNames | right.varNames)


    def namesUsed(self):
        """
        What are the names of variables used by this expression that refer to
        variables defined outside this expression?

        Union of namesRead and namesSet.
        """
        return self.namesRead | self.namesSet

    def outNames(self):
        """
        What variables are defined in this expression that are visible after
        this expression (i.e., to its right)?

        Union of defNames and varNames.
        """

        return self.defNames | self.varNames

    def __repr__(self):
        return "<%r := %r =~ %r + var %r %s>" % (list(self.namesSet),
                                                 list(self.namesRead),
                                                 list(self.defNames),
                                                 list(self.varNames),
                                                 ("meta.getState()"
                                                  if self.metaStateExprFlag
                                                  else ""))

def getExports(scope, used):
    outs = scope.outNames()
    if used is not None and not used.metaStateExprFlag:
        outs = outs & used.namesUsed()
    return outs

def union(initial, scopes):
    return reduce(StaticScope.add, scopes, initial)

def foldr(f, a, bs):
    for b in bs:
        a = f(a, b)
    return a

def verbAssignError(target, parser):
    name = target.tag.name
    if name == "QuasiLiteralExpr":
        err("Can't use update-assign syntax on a \"$\"-hole. "
            "Use explicit \":=\" syntax instead.", parser)
    elif name == "QuasiPatternExpr":
        err("Can't use update-assign syntax on a \"@\"-hole. "
            "Use explicit \":=\" syntax instead.", parser)
    else:
        err("Can only update-assign nouns and calls", parser)

def err(msg, parser):
    raise parser.input.error.withMessage([("message", msg)])

def expandCallVerbAssign(verb, args, receiver, methVerb, methArgs):
    r = mktemp("recip")
    prelude = t.Def(t.FinalPattern(r, None), None, receiver)
    seq = [prelude]
    setArgs = []
    for arg in methArgs.args:
        a = mktemp("arg")
        seq.append(t.Def(t.FinalPattern(a, None), None, arg))
        setArgs.append(a)
    seq.extend(expand(t.Assign(t.MethodCallExpr(r, methVerb, setArgs), t.MethodCallExpr(t.MethodCallExpr(r, methVerb, setArgs),
                               verb, args))).args[0].args)
    return t.SeqExpr(seq)


def expandDef(patt, optEj, rval, nouns):
    pattScope = scope(patt)
    defPatts = pattScope.defNames
    varPatts = pattScope.varNames
    rvalScope = scope(rval)
    if optEj:
        rvalScope = scope(optEj).add(rvalScope)
    rvalUsed = rvalScope.namesUsed()
    commonNames = pattScope.outNames() & rvalScope.namesUsed().getKeys()
    if len(varPatts & rvalUsed) != 0:
        raise ParseError("Circular 'var' definition not allowed", None)
    if len(pattScope.namesUsed() & rvalScope.outNames()) != 0:
        raise ParseError("Pattern may not use var defined on the right", None)
    conflicts = defPatts & rvalUsed
    if len(conflicts) == 0:
        return t.Def(patt, optEj, rval)
    else:
        promises = []
        resolves = []
        renamings = {}
        for oldNameStr in conflicts.getKeys():
            newName = mktemp(oldNameStr)
            newNameR = mktemp(oldNameStr + "R")
            renamings[oldNameStr] = newName
             # def [newName, newNameR] := Ref.promise()
            pair = [t.FinalPattern(newName, None),
                    t.FinalPattern(newNameR, None)]
            promises.append(t.Def(t.ListPattern(pair, None), None,
                                  mcall("Ref", "promise")))
            resolves.append(t.MethodCallExpr(newNameR, "resolve",
                                            [t.NounExpr(oldNameStr)]))
        resName = mktemp("res")
        resolves.append(resName)
        cr = CycleRenamer([rval])
        cr.renamings = renamings
        rval =  cr.apply("transform")[0]
        resPatt = t.FinalPattern(resName, None)
        resDef = t.Def(resPatt, None, t.Def(patt, optEj, rval))
        return t.SeqExpr(promises + [resDef] + resolves)

computeStaticScopeRules = """
null = anything:t ?(t.tag.name == 'null') -> StaticScope()
LiteralExpr(:val) -> StaticScope()
NounExpr(@name) -> StaticScope(namesRead=[name])
TempNounExpr(@name @idx) -> StaticScope(namesRead=[name + str(idx)])
SlotExpr(@name) -> StaticScope(namesRead=[name])
BindingExpr(NounExpr(@name)) -> StaticScope(namesRead=[name])
HideExpr(@blockScope) -> blockScope.hide()
SeqExpr(@scopes) -> reduce(StaticScope.add, scopes)
MethodCallExpr(@receiverScope :verb @argScopes) -> union(receiverScope, argScopes)

Def(@patternScope @exitScope @exprScope) -> patternScope.add(exitScope).add(exprScope)
Assign(NounExpr(@name) @rightScope) -> StaticScope(namesSet=[name]).add(rightScope)
Assign(TempNounExpr(@name @idx) @rightScope) -> StaticScope(namesSet=[name + str(idx)]).add(rightScope)

IgnorePattern(@guardScope) -> guardScope
VarPattern(NounExpr(@name) @guardScope) -> StaticScope(varNames=[name]).add(guardScope)
FinalPattern(NounExpr(@name) @guardScope) -> StaticScope(defNames=[name]).add(guardScope)
SlotPattern(NounExpr(@name) @guardScope) -> StaticScope(varNames=[name]).add(guardScope)
BindingPattern(NounExpr(@name)) -> StaticScope(varNames=[name])
ListPattern(@patternScopes null) -> union(StaticScope(), patternScopes)
ViaPattern(@exprScope @patternScope) -> exprScope.add(patternScope)


Object(@doco @nameScope
       Script(@extends @implementScopes
              @methodScopes @matchers)) -> nameScope.add(union(implementsScopes + methodScopes + matcherScopes,
                                                               StaticScope()))
Method(@doco @verb @paramsScope @guardScope @blockScope) -> union(paramsScope + [guardScope, blockScope.hide()],
                                                                  StaticScope()).hide()
Matcher(@patternScope @blockScope) -> patternScope.add(blockScope).hide()

If(@testScope @consqScope @altScope) -> testScope.add(consqScope).hide().add(altScope).hide()
KernelTry(@tryScope @patternScope @catchScope) -> tryScope.hide().add(patternScope.add(catchScope)).hide()
Finally(@tryScope @finallyScope) -> tryScope.hide().add(finallyScope).hide()
Escape(@ejScope @bodyScope Catch(@argScope @catcherScope)) -> ejScope.add(bodyScope).hide().add(argScope.add(catcherScope)).hide()
Escape(@ejScope @bodyScope null) -> ejScope.add(bodyScope).hide()

MatchBind(maybeDelayedNode:specimen expand:pattern) -> specimen.add(pattern)

LogicalAnd(delayed:left  delayed:right) -> self.expandAndScope(left).add(self.expandAndScope(right))
LogicalAnd(delayed:left  @rightScope) -> self.expandAndScope(left).add(right)
LogicalAnd(@leftScope delayed:right) -> leftScope.add(self.expandAndScope(right))
LogicalAnd(@leftScope @rightScope) -> leftScope.add(rightScope)

LogicalOr(expand:left expand:right) -> StaticScope(left.namesRead | right.namesRead,
                                                   left.namesSet | right.namesSet,
                                                   left.metaStateExprFlag or right.metaStateExprFlag,
                                                   left.defNames | right.defNames,
                                                   left.varNames | right.varNames)

expand = :node -> scope(expand(node))
delayed = :node ?(isDelayedNode(node)) -> scope(expand(node))

"""

def isDelayedNode(node):
    return node.tag.name in ["MatchBind", "LogicalAnd", "LogicalOr"]

def scope(term):
    x = StaticScopeTransformer.transform(term)[0]
    if x is None:
        return StaticScope()
    return x

def mcall(noun, verb, *expr):
    return t.MethodCallExpr(t.NounExpr(noun), verb, expr)

def putVerb(verb):
    if verb == "get":
        return "put"
    elif verb == "run":
        return "setRun"
    elif verb.startswith("get"):
        return "set"+verb[3:]
    elif verb.startswith("__get"):
        return "__set"+verb[5:]

def buildQuasiExpr(pairs):
    textParts = []
    exprParts = []
    for text, expr in pairs:
        if expr:
            textParts.append("${%s}" % (len(exprParts),))
            exprParts.append(expr)
        else:
            textParts.append(text)
    return ''.join(textParts), exprParts


#implicit rules:
# data transforms to itself
# tuples transform to tuples with each item transformed
# other terms transform to terms of the same name with each arg transformed
expander = """

#no args and lowercase means this isn't automatically treated as a
#term, so we explicitly deal with it here
null = anything:t ?(t.tag.name == 'null')

nameAndString = NounExpr(:name):e !(self.nouns.add(name)) -> e, name.data
     | SlotExpr(:name):e -> e, '&' + name.data
     | BindingExpr(:name):e -> e, '&&' + name.data

     | VarPattern(name:name :guard):p transform(p):e -> e, name
     | BindPattern(name:name :guard):p transform(p):e -> e, name
     | FinalPattern(name:name :guard):p transform(p):e -> e, name
     | SlotPattern(name:name :guard):p transform(p):e -> e, '&' + name
     | BindingPattern(name:name :guard):p transform(p):e -> e, '&&' + name

name = NounExpr(:name) !(self.nouns.add(name)) -> name.data
     | SlotExpr(:name) -> '&' + name.data
     | BindingExpr(:name) -> '&&' + name.data


NounExpr(:name) !(self.nouns.add(name)) -> t.NounExpr(name)
URIExpr(@scheme @body) -> mcall(scheme + "__uriGetter", "get", t.LiteralExpr(body))
URIGetter(@scheme) -> t.NounExpr(scheme + "__uriGetter")
MapExpr(@assocs) -> mcall("__makeMap", "fromPairs", mcall("__makeList", "run", *[mcall("__makeList", "run", *a) for a in assocs]))
MapExprAssoc(@key @value) -> [key, value]
MapExprExport(nameAndString:pair) -> [t.LiteralExpr(pair[1]), pair[0]]

ListExpr(@items) -> mcall("__makeList", "run", *items)

QuasiExpr(null quasis:qs) -> mcall(mcall("simple__quasiParser", "valueMaker", qs[0]), "substitute", qs[1])
QuasiExpr(:name quasis:qs) -> mcall(mcall(name + "__quasiParser", "valueMaker", qs[0]), "substitute", qs[1])

quasis = (qtext | qehole)*:pairs -> buildQuasiExpr(pairs)
qtext = QuasiText(:text) -> (text, None)
qehole = QuasiExprHole(@expr) -> (None, expr)

SeqExpr([]) -> None
SeqExpr([(forFx:v ~~forFx -> v)*:exprs @last]) -> t.SeqExpr(exprs + [last])

VerbCurryExpr(@receiver :verb) -> mcall("__makeVerbFacet", "curryCall", receiver, t.LiteralExpr(verb))
GetExpr(@receiver @index) -> t.MethodCallExpr(receiver, "get", index)
FunctionCallExpr(@receiver @args) -> t.MethodCallExpr(receiver, "run", args)
FunctionSendExpr(@receiver @args) -> mcall("E", "send", receiver, t.LiteralExpr("run"), args)
MethodSendExpr(@receiver :verb @args) -> mcall("E", "send", receiver, t.LiteralExpr(verb), mcall("__makeList", "run", *args))
SendCurryExpr(@receiver :verb) -> mcall("__makeVerbFacet", "currySend", receiver, t.LiteralExpr(verb))

Minus(@receiver) -> t.MethodCallExpr(receiver, "negate", [])
LogicalNot(@receiver) -> t.MethodCallExpr(receiver, "not", [])
BinaryNot(@receiver) -> t.MethodCallExpr(receiver, "complement", [])

Pow(@left @right) -> binop("pow", left, right)
Multiply(@left @right) -> binop("multiply", left, right)
Divide(@left @right) -> binop("approxDivide", left, right)
FloorDivide(@left @right) -> binop("floorDivide", left, right)
Remainder(@left @right) -> binop("remainder", left, right)
Mod(Pow(@x @y) @z) -> t.MethodCallExpr(x, "modPow", [y, z])
Mod(MethodCallExpr(@x "pow" [@y]) @z) -> t.MethodCallExpr(x, "modPow", [y, z])
Mod(@left @right) -> binop("mod", left, right)
Add(@left @right) -> binop("add", left, right)
Subtract(@left @right) -> binop("subtract", left, right)
ShiftRight(@left @right) -> binop("shiftRight", left, right)
ShiftLeft(@left @right) -> binop("shiftLeft", left, right)
Till(@left @right) -> mcall("__makeOrderedSpace", "op__till", left, right)
Thru(@left @right) -> mcall("__makeOrderedSpace", "op__thru", left, right)
GreaterThan(@left @right) -> mcall("__comparer", "greaterThan", left, right)
GreaterThanEqual(@left @right) -> mcall("__comparer", "geq", left, right)
AsBigAs(@left @right) -> mcall("__comparer", "asBigAs", left, right)
LessThanEqual(@left @right) -> mcall("__comparer", "leq", left, right)
LessThan(@left @right) -> mcall("__comparer", "lessThan", left, right)
Coerce(@spec @guard) -> t.MethodCallExpr(mcall("Guard", "coerce", guard, t.NounExpr("null")), "coerce", [spec, t.NounExpr("null")])

MatchBind(@spec @patt) = matchBind_forValue(spec patt)
Mismatch(@spec @patt) = matchBind_forValue(spec patt):expr -> t.MethodCallExpr(expr, "not", [])

Same(@left @right) -> mcall("__equalizer", "sameEver", left, right)
NotSame(@left @right) -> t.MethodCallExpr(mcall("__equalizer", "sameEver", left, right), "not", [])

ButNot(@left @right) -> binop("butNot", left, right)
BinaryOr(@left @right) -> binop("or", left, right)
BinaryAnd(@left @right) -> binop("and", left, right)
BinaryXor(@left @right) -> binop("xor", left, right)

LogicalAnd(:left :right) -> expandLogicalAnd_forValue(left, right, self.scope)
LogicalOr(:left :right) -> expandLogicalOr_forValue(left, right, self.scope)

Def(@pattern @exit @expr) -> expandDef(pattern, exit, expr, self.nouns)

Forward(@name) !(t.NounExpr(name.args[0].data + "__Resolver")):rname -> t.SeqExpr([
                                            t.Def(t.ListPattern([
                                                      t.FinalPattern(name, None),
                                                      t.FinalPattern(rname, None)],
                                                  None),
                                            None,
                                          mcall("Ref", "promise")),
                                        rname])

Assign(@left @right) = ass(left right)
ass NounExpr(:name) :right -> t.Assign(t.NounExpr(name), right)
ass MethodCallExpr(@receiver @verb @args):left :right !(mktemp("ares")):ares -> t.SeqExpr([t.MethodCallExpr(receiver, putVerb(verb), args + [t.Def(t.FinalPattern(ares, None), None, right)]), ares])
ass :left :right -> err("Assignment can only be done to nouns and collection elements", self)


VerbAssign(:verb @target @args) = vass(verb target args)

vass :verb NounExpr(@name) :args -> t.Assign(t.NounExpr(name), mcall(name, verb, *args))
vass :verb MethodCallExpr(@receiver :methVerb :methArgs) :args -> expandCallVerbAssign(verb, args, receiver, methVerb, methArgs)
vass :verb :badTarget :args -> verbAssignError(badTarget, self)

AugAssign(@op :left :right) -> expand(t.VerbAssign(binops[op], left, [right]))

Break(null) -> mcall("__break", "run")
Break(@expr) -> mcall("__break", "run", expr)

Continue(null) -> mcall("__continue", "run")
Continue(@expr) -> mcall("__continue", "run", expr)

Return(null) -> mcall("__return", "run")
Return(@expr) -> mcall("__return", "run", expr)

Guard(:expr :subscripts) -> expand(reduce(lambda e, s: t.GetExpr(e, s), subscripts.args, expr))

#IgnorePattern(@guard) -> t.IgnorePattern(guard)

SamePattern(@value) -> t.ViaPattern(mcall("__is", "run", value), t.IgnorePattern(None))

VarPattern(@name @guard) = -> t.VarPattern(name, guard)

BindPattern(@name @guard) -> t.ViaPattern(mcall("__bind", "run", [name.args[0].data + "__Resolver", guard]), t.IgnorePattern(None))

#FinalPattern(@name @guard) -> t.FinalPattern(name, guard)

#SlotPattern(@name @guard) -> t.SlotPattern(name, guard)

MapPattern(@assocs @tail) -> foldr(lambda more, (l, r): t.ViaPattern(l, t.ListPattern([r, more], None)),
                                   tail or t.IgnorePattern(t.NounExpr("__Empty")),
                                   reversed(assocs))

MapPatternAssoc(@key @value) -> [key, value]
MapPatternImport(nameAndString:nameAnd) -> [t.LiteralExpr(nameAnd[1]), nameAnd[0]]
MapPatternOptional(@assoc @default) -> [mcall("__extract", "depr", assoc[0], default), assoc[1]]
MapPatternRequired(@assoc) -> (mcall("__extract", "run", assoc[0]), assoc[1])
ListPattern(@patterns null) -> t.ListPattern(patterns, None)
ListPattern(@patterns @tail) -> t.ViaPattern(mcall("__splitList", "run", t.LiteralExpr(len(patterns))), patterns)

SuchThatPattern(@pattern @expr) -> t.ViaPattern(t.NounExpr("__suchThat"),
                                      t.ListPattern([pattern, t.ViaPattern(mcall("__suchThat", "run", expr))], None))

Interface(@doco nameAndString:nameAnd @guard @extends @implements
          InterfaceFunction(:params :resultGuard))
     -> expandInterface(doco, nameAnd[0], nameAnd[1], guard, extends,
                        implements,
                        [self.transform(t.MessageDesc("", "to", "run",
                                                      params, resultGuard))])
Interface(@doco nameAndString:nameAnd @guard @extends @implements @script)
     -> expandInterface(doco, nameAnd[0], nameAnd[1], guard, extends,
                        implements, script)

MessageDesc(@doco @type @verb @paramDescs @guard)
     -> t.HideExpr(mcall("__makeMessageDesc", "run",
                         doco and t.LiteralExpr(doco), t.LiteralExpr(verb),
                         mcall("__makeList", "run", *paramDescs),
                         guard or t.NounExpr("void")))

ParamDesc(name:name @guard) -> mcall("__makeParamDesc", "run", t.LiteralExpr(name), guard or t.NounExpr("any"))


Lambda(@doco @patterns @block) -> t.Object(doco, t.IgnorePattern(None),
                                      t.Script(None, None, [],
                                               [t.Method(None, "run", patterns,
                                                         None, block)],
                                               []))

Object(:doco BindPattern(:name :guard):bp :script):o transform(bp):exName
     transform(t.Object(doco, t.FinalPattern(t.NounExpr(name), None), script)):exObj
 -> t.Def(exName, None, t.HideExpr(exObj))

Object(@doco @name Function(@params @guard @implements @block))
    -> t.Object(doco, name, t.Script(None, None, implements,
                                  [t.Method(doco, "run", params, guard,
                                       t.Escape(t.FinalPattern(t.NounExpr("__return"), None),
                                           t.SeqExpr([block, t.NounExpr("null")]), None))],
                                  []))

Object(@doco @name Script(null @guard @implements @methods @matchers)) -> t.Object(doco, name, t.Script(None, guard, implements, methods, matchers))

Object(@doco VarPattern(:name :guard):vp Script(@extends @guard @implements @methods @matchers)) transform(vp):exVP
    objectSuper(doco exVP extends guard implements methods matchers [t.SlotExpr(name.args[0].data)]):o
    -> t.SeqExpr([t.Def(t.SlotPattern(name, None), None, o), name])

Object(@doco @name Script(@extends @guard @implements @methods @matchers)) =
    objectSuper(doco name extends guard implements methods matchers []):o -> t.Def(name, None, o)

objectSuper :doco :name :extends :guard :implements :methods :matchers :maybeSlot !(mktemp("pair")):p -> t.HideExpr(t.SeqExpr([
       t.Def(t.FinalPattern(t.NounExpr("super"), None),
           None, extends),
       t.Object(doco, name,
           t.Script(None, guard, implements, methods,
               matchers + [t.Matcher(t.FinalPattern(p, None),
                           mcall("E", "callWithPair", t.NounExpr("super"), p))]))
       ] + maybeSlot))
To(:doco @verb @params @guard @block) -> t.Method(doco, verb, params, guard, t.Escape(t.FinalPattern(t.NounExpr("__return"), None),
                                                  t.SeqExpr([block, t.NounExpr("null")]), None))

Accum(@base !(mktemp("accum")):tmp accum(tmp):accumulator) -> t.SeqExpr(
    [t.Def(t.VarPattern(tmp, None), None, base), accumulator, tmp])

accum :tmp = (AccumFor(:left :right :expr accum(tmp):body @catcher) forValue(expr body):coll -> expandFor(left, right, coll, body, catcher)
             |AccumIf(@expr accum(tmp):body) expandIf(expr body)
             |AccumWhile(@test accum(tmp):body @catcher) expandWhile(test body catcher)
             |AccumOp(@op @expr) -> t.Assign(tmp, binop(binops[op], tmp, expr))
             |AccumCall(:verb @args) -> t.Assign(tmp, t.MethodCallExpr(tmp, verb, args)))

For(:key :value :expr @block @catcher) forValue(expr block):coll
    -> expandFor(self, key, value, coll, block, catcher)

If(:test @consq @alt) -> expandIf(test, consq, alt)

Switch(@expr :matchers) !(mktemp("specimen")):sp -> expand(t.HideExpr(t.SeqExpr([
                                                        t.Def(t.FinalPattern(sp, None),
                                                            None, expr),
                                                        matchExpr(matchers, sp)])))

Try(@tryblock null null) -> t.HideExpr(tryblock)
Try(@tryblock null @finallyblock) -> t.Finally(tryblock, finallyblock)
Try(@tryblock [Catcher(@pattern @block)] @finallyblock) kerneltry(t.KernelTry(tryblock, pattern, block) finallyblock)
Try(@tryblock :catchers @finallyblock) !(mktemp("sp")):sp kerneltry(t.KernelTry(tryblock, t.FinalPattern(sp, None), expand(matchExpr(catchers, sp))) finallyblock)

kerneltry :tryexpr null -> tryexpr
kerneltry :tryexpr :finallyexpr -> t.Finally(tryexpr, finallyexpr)

While(:test :block @catcher) -> t.Escape(t.FinalPattern(t.NounExpr("__break"), None), mcall("__loop", "run", t.Object("While loop body", t.IgnorePattern(None), t.Script(None, None, [], [t.Method(None, "run", [], t.NounExpr("boolean"), expand(t.If(test, t.SeqExpr([t.Escape(t.FinalPattern(t.NounExpr("__continue"), None), block, None), t.NounExpr("true")]), t.NounExpr("false"))))], []))), catcher)

When([@arg] @block :catchers @finallyblock) expandWhen(arg block catchers finallyblock)
When(:args @block :catchers :finallyblock) expandWhen(mcall("promiseAllFulfilled", "run", expand(t.ListExpr(args))) block catchers finallyblock)

expandWhen :arg :block :catchers :finallyblock = expandWhenCatchers(catchers):cs !(mktemp("resolution")):resolution -> t.HideExpr(mcall("Ref", "whenResolved", arg, t.Object("when-catch 'done' function", t.IgnorePattern(None), t.Script(None, None, [], [t.Method(None, "run", [t.FinalPattern(resolution, None)], None, expand(t.Try(t.SeqExpr([t.Def(t.IgnorePattern(None), None, mcall("Ref", "fulfillment", resolution)), block]), [cs], finallyBlock)))]))))

expandWhenCatchers null !(mktemp("ex")):ex -> t.Catch(t.FinalPattern(ex, None), mcall("throw", "run", ex))
expandWhenCatchers [catcher] -> catcher
expandWhenCatchers :catchers !(mktemp("specimen")):sp -> t.Catch(t.FinalPattern("specimen", None), matchExpr(catchers, sp))



forValue MatchBind(@spec @patt) :block -> matchBind_forValue(spec, patt, scope(block))
forValue @expr :scope -> expr


matchBind_forFxOnly :spec :patt :exports !(getExports(scope(spec))):exports (
    ?(exports) !(mktemp("sp")):sp -> t.SeqExpr([t.Def(t.FinalPattern(sp, None),
                                                      None, spec),
                                                expandForFxOnly(
                                                    t.MatchBind(sp, patt),
                                                    self.scope)])
    | -> defaultFxOnlyExpander(self.scope))

matchBind_forControl :spec :patt :ej -> t.Def(patt, ej, spec)

delayed_forControl :node

"""

def matchExpr(matchers, var):
    result = t.MethodCallExpr(t.NounExpr("throw"), "run",
                            [t.MethodCallExpr(t.LiteralExpr("no match: "),
                                            "add", [var])])
    for m in reversed(matchers.args):
        result = t.If(t.MatchBind(var, m.args[0]), m.args[1], result)
    return result

def binop(name, left, right):
    return t.MethodCallExpr(left, name, [right])

def expandInterface(doco, name, nameStr, guard, extends, implements, script):
    return t.Def(name,
                 None,
                 t.HideExpr(
                     mcall("__makeProtocolDesc", "run", doco and t.LiteralExpr(doco),
                           t.MethodCallExpr(
                               t.MethodCallExpr(t.Meta("context"), "getFQNPrefix", []),
                               "add", [t.LiteralExpr(nameStr + "__T")]),
                           mcall("__makeList", "run", *extends),
                           mcall("__makeList", "run", *implements),
                           mcall("__makeList", "run", *script))))

def validateFor(self, left, right):
    if left.outNames() & right.namesUsed():
        err("Use on right isn't really in scope of definition", self)
    if right.outNames() & left.namesUsed():
        err("Use on left would get captured by definition on right", self)

def expandFor(self, key, value, coll, block, catcher):
    validateFor(self, scope(key).add(scope(value)), scope(coll))
    fTemp = mktemp("validFlag")
    kTemp = mktemp("key")
    vTemp = mktemp("value")
    body = expand(t.If(t.LogicalAnd(t.MatchBind(kTemp, key)),
                       t.MatchBind(vTemp, value),
                       t.Escape(t.FinalPattern(t.NounExpr("__continue"), None),
                                t.SeqExpr([block, t.NounExpr("null")]),
                                None),
                       None))
    obj = t.Object(
        "For-loop body", t.IgnorePattern(None),
        t.Script(None, None, [],
                 [t.Method(None, "run",
                           [t.FinalPattern(kTemp, None),
                            t.FinalPattern(vTemp, None)],
                           None,
                           t.SeqExpr([
                               mcall("require", "run", fTemp,
                                     t.LiteralExpr("For-loop body isn't valid"
                                                   " after for-loop exits.")),
                               body])
                       )],
                 []))
    return t.Escape(
        t.FinalPattern(t.NounExpr("__break"), None),
        t.SeqExpr([t.Def(
            t.VarPattern(fTemp, None), None,
            t.NounExpr("true")),
                   t.Finally(
                       t.MethodCallExpr(
                           coll, "iterate",
                           [obj]),
                       t.Assign(fTemp, t.NounExpr("false"))),
                   t.NounExpr("null")]),
        catcher)

def expandIf(test, consq, alt):
    if isDelayedNode(test):
        ej1 = mktemp("ej")
        return t.Escape(t.FinalPattern(ej1, None),
                        t.SeqExpr([delayed_forControl(test, ej1, scope(consq)),
                                   consq]),
                        t.Catch(t.IgnorePattern(None), alt))

def matchBind_forValue(spec, patt, currentScope):
    exports = getExports(scope(spec), currentScope)
    if exports:
        sp = mktemp("sp")
        return t.SeqExpr([t.Def(t.FinalPattern(sp, None), None, spec),
                          expand(t.MatchBind(sp, patt), currentScope)])
    else:
        return delayed_forValue(t.MatchBind(spec, patt), currentScope)

def broke(br, ex):
    return t.Def(t.FinalPattern(br, None),
                 mcall("Ref", "broken", mcall("__makeList", "run", ex)))

def slotsTuple(first, rest):
    return mcall("__makeList", "run", first, *[t.SlotExpr(x) for x in rest])

def slotsPattern(first, rest):
    if first:
        return t.ListPattern([first] + [t.SlotPattern(x, None) for x in rest])
    else:
        return t.ListPattern([t.SlotPattern(x, None) for x in rest])

def expandForControl(node, ej, sc):
    if node.tag.name == 'MatchBindExpr':
        spec, patt = transform(node.args[0]), transform(node.args[1])
        return t.Def(patt, ej, spec)
    elif node.tag.name == 'LogicalAnd':
        left, right = node.args[0], node.args[1]
        if sc is  None:
            midscope = None
        else:
            midscope = scope(right).add(sc)
        return t.SeqExpr([expandForControl(left, ej, midscope),
                          expandForControl(right, ej, sc)])
    elif node.tag.name == 'LogicalOr':
        left, right = node.args[0], node.args[1]
        ej1 = mktep("ej")
        exports = getExports(sc)
        if exports:
            br2 = mktemp("br")
            ex3 = mktemp("ex")
            br4 = mktemp("br")
            rightSkipped = t.LiteralExpr("right side skipped")
            leftOuts = scope(left).outNames()
            rightOuts = scope(right).outNames()
            return t.Def(slotsPattern(None, exports),
                         t.Escape(t.FinalPattern(ej1, None),
                                  t.SeqExpr([expandForControl(left, ej1, sc),
                                             broke(br2, rightSkipped),
                                             mixOuts(exports, leftOuts, br2)])))

def delayed_forValue(node, scope):
    ej1 = mktemp("ej")
    exports = getExports(scope)
    ctrl = expandForControl(node, ej1, scope)
    if exports:
        ex2 = mktemp("ex")
        br3 = mktemp("br")
        rs4 = mktemp("rs")
        escExpr = t.Escape(t.FinalPattern(ej1, None),
                           t.SeqExpr(ctrl, slotsTuple(TRUE, exports)),
                           t.Catch(
                               t.FinalPattern(ex2, None),
                               t.SeqExpr([broke(br3, ex2),
                                          mcall("__makeList", "run", FALSE, br3)])))
        return t.SeqExpr([t.Def(slotsPattern(t.FinalPattern(rs4), exports), escExpr),
                          rs4])

binops =  {"Add": "add",
           "Subtract": "subtract",
           "Multiply": "multiply",
           "Divide": "approxDivide",
           "Remainder": "remainder",
           "Mod": "mod",
           "Pow": "pow",
           "FloorDivide": "floorDivide",
           "ShiftRight": "shiftRight",
           "ShiftLeft": "shiftLeft",
           "BinaryAnd": "and",
           "BinaryOr": "or",
           "BinaryXor": "xor",
           "ButNot": "butNot",
           }

reifier = r"""
TempNounExpr(:basename :id) -> reifyNoun(self.nouns, basename.data, id)
"""
def reifyNoun(nouns, base, id):
    count = 1
    cached = nouns.get((base, id))
    if cached:
        return cached
    noun = "%s__%s" % (base, count)
    while noun in nouns:
        count += 1
        noun = "%s__%s" % (base, count)
    nouns[base, id] = n = t.NounExpr(noun)
    return n

cycleRenamer = r"""
NounExpr(@name) (?(name in self.renamings) -> self.renamings[name]
                |                          -> t.NounExpr(name))
"""

def expand(term, scope=None):
    e = Expander([term])
    e.scope = scope
    e.nouns = set()
    expanded = e.apply("transform")[0]
    r = Reifier([expanded])
    r.nouns = dict.fromkeys(e.nouns)
    reified = r.apply("transform")[0]
    return reified

counter = 0
def mktemp(name):
    global counter
    counter += 1
    return t.TempNounExpr(name, counter)

StaticScopeTransformer = TreeTransformerGrammar.makeGrammar(computeStaticScopeRules, "StaticScopeTransformer").createParserClass(TreeTransformerBase, globals())


Expander = TreeTransformerGrammar.makeGrammar(expander, name="EExpander").createParserClass(TreeTransformerBase, globals())

Reifier = TreeTransformerGrammar.makeGrammar(reifier, name="Reifier").createParserClass(TreeTransformerBase, globals())

CycleRenamer = TreeTransformerGrammar.makeGrammar(cycleRenamer, name="CycleRenamer").createParserClass(TreeTransformerBase, globals())
