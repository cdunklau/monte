from ometa.grammar import TreeTransformerGrammar
from ometa.runtime import TreeTransformerBase, ParseError
from terml.nodes import termMaker as t
### XXX TODO: Create TemporaryExprs for variables generated by
### expansion. Replace all temps with nouns in a single pass at the
### end.

class ScopeSet(object):
    def __init__(self, bits=()):
        self.contents = list(bits)[:]

    def __sub__(self, other):
        bits = self.contents[:]
        for bit in other:
            if bit in bits:
                bits[bits.index(bit)] = bits[-1]
                del bits[-1]
        return ScopeSet(bits)

    def __and__(self, other):
        if len(self) > len(other):
            big = self.contents
            small = list(other)
        else:
            small = self.contents
            big = list(other)
        bits = []
        for bit in small:
            if bit in big:
                bits.append(bit)
        return ScopeSet(bits)

    def __or__(self, other):
        bits = list(other)
        for bit in self.contents:
            if bit not in bits:
                bits.append(bit)
        return ScopeSet(bits)

    def getKeys(self):
        return self.contents[:]

    def __iter__(self):
        return iter(self.contents)

    def __len__(self):
        return len(self.contents)

class StaticScope(object):
    def __init__(self, namesRead=None, namesSet=None, metaStateExprFlag=False,
                 defNames=None, varNames=None):
        if namesRead is None:
            namesRead = ScopeSet()
        if namesSet is None:
            namesSet = ScopeSet()
        if defNames is None:
            defNames = ScopeSet()
        if varNames is None:
            varNames = ScopeSet()
        self.namesRead = ScopeSet(namesRead)
        self.namesSet = ScopeSet(namesSet)
        self.defNames = ScopeSet(defNames)
        self.varNames = ScopeSet(varNames)
        self.metaStateExprFlag = metaStateExprFlag

    def hide(self):
        return StaticScope(self.namesRead, self.namesSet,
                           self.metaStateExprFlag,
                           None, None)
    def add(self, right):
        """
        For processing normal expressions left to right, where all definitions
        are exported, but uses are hidden by definitions to their left.
        """
        if right is None:
            return self
        rightNamesRead = (right.namesRead - self.defNames) - self.varNames
        rightNamesSet = (right.namesSet - self.varNames)
        badAssigns = rightNamesSet & self.defNames
        #XXX slavishly porting Java code etc
        if (1 <= len(badAssigns)):
            rightNamesSet = rightNamesSet - badAssigns

        return StaticScope(self.namesRead | rightNamesRead,
                           self.namesSet | rightNamesSet,
                           self.metaStateExprFlag or right.metaStateExprFlag,
                           self.defNames | right.defNames,
                           self.varNames | right.varNames)


    def namesUsed(self):
        """
        What are the names of variables used by this expression that refer to
        variables defined outside this expression?

        Union of namesRead and namesSet.
        """
        return self.namesRead | self.namesSet

    def outNames(self):
        """
        What variables are defined in this expression that are visible after
        this expression (i.e., to its right)?

        Union of defNames and varNames.
        """

        return self.defNames | self.varNames

    def __repr__(self):
        return "<%r := %r =~ %r + var %r %s>" % (list(self.namesSet),
                                                 list(self.namesRead),
                                                 list(self.defNames),
                                                 list(self.varNames),
                                                 ("meta.getState()"
                                                  if self.metaStateExprFlag
                                                  else ""))

def getExports(scope, used):
    outs = scope.outNames()
    if used is not None and not used.metaStateExprFlag:
        outs = outs & used.namesUsed()
    return outs

def union(initial, scopes):
    return reduce(StaticScope.add, scopes, initial)

def foldr(f, a, bs):
    for b in bs:
        a = f(a, b)
    return a

def verbAssignError(target, parser):
    name = target.tag.name
    if name == "QuasiLiteralExpr":
        err("Can't use update-assign syntax on a \"$\"-hole. "
            "Use explicit \":=\" syntax instead.", parser)
    elif name == "QuasiPatternExpr":
        err("Can't use update-assign syntax on a \"@\"-hole. "
            "Use explicit \":=\" syntax instead.", parser)
    else:
        err("Can only update-assign nouns and calls", parser)

def err(msg, parser):
    raise parser.input.error.withMessage([("message", msg)])

def expandCallVerbAssign(verb, args, receiver, methVerb, methArgs):
    r = mktemp("recip")
    prelude = t.Def(t.FinalPattern(r, None, None), None, receiver)
    seq = [prelude]
    setArgs = []
    for arg in args:
        a = mktemp("arg")
        seq.append(t.Def(t.FinalPattern(a, None), arg))
        setArgs.append(a)
    seq.extend(expand(t.Assign(t.MethodCallExpr(r, verb, setArgs), t.MethodCallExpr(t.MethodCallExpr(r, verb, setArgs),
                               methVerb, methArgs))).args[0].args)
    return t.SeqExpr(seq)


def expandDef(patt, optEj, rval):
    pattScope = scope(patt)
    defPatts = pattScope.defNames
    varPatts = pattScope.varNames
    rvalScope = scope(rval)
    if optEj:
        rvalScope = scope(optEj).add(rvalScope)
    else:
        optEj = None
    rvalUsed = rvalScope.namesUsed()
    if len(varPatts & rvalUsed) != 0:
        raise ParseError("Circular 'var' definition not allowed", None)
    if len(pattScope.namesUsed() & rvalScope.outNames()) != 0:
        raise ParseError("Pattern may not use var defined on the right", None)
    conflicts = defPatts & rvalUsed
    if (0 >= len(conflicts)):
        return t.Def(patt, optEj, rval)
    else:
        promises = []
        resolves = []
        for oldNameStr in conflicts:
            newName = mktemp(oldNameStr)
            newNameR = mktemp(oldNameStr + "R")
             # def [newName, newNameR] := Ref.promise()
            pair = [t.FinalPattern(newName, None),
                    t.FinalPattern(newNameR, None)]
            promises.append(t.Def(t.ListPattern(pair, None), None,
                                  mcall("Ref", "promise")))
            resolves.append(t.MethodCallExpr(newNameR, "resolve",
                                            [t.NounExpr(oldNameStr)]))
        resName = mktemp("res")
        resolves.append(resName)
        resPatt = t.FinalPattern(resName, None)
        resDef = t.Def(resPatt, None, t.Def(patt, optEj, rval))
        return t.SeqExpr(promises + [resDef] + resolves)

computeStaticScopeRules = """
null = anything:t ?(t.tag.name == 'null')
LiteralExpr(:val) -> StaticScope()
NounExpr(@name) -> StaticScope(namesRead=[name])
SlotExpr(@name) -> StaticScope(namesRead=[name])
BindingExpr(NounExpr(@name)) -> StaticScope(namesRead=[name])
HideExpr(@blockScope) -> blockScope.hide()
SeqExpr(@scopes) -> reduce(StaticScope.add, scopes)
MethodCallExpr(@receiverScope :verb @argScopes) -> union(receiverScope, argScopes)

Def(@patternScope @exitScope @exprScope) -> patternScope.add(exitScope).add(exprScope)
Assign(NounExpr(@name) @rightScope) -> StaticScope(namesSet=[name]).add(rightScope)

IgnorePattern(@guardScope) -> guardScope
VarPattern(NounExpr(@name) @guardScope) -> StaticScope(varNames=[name]).add(guardScope)
FinalPattern(NounExpr(@name) @guardScope) -> StaticScope(defNames=[name]).add(guardScope)
SlotPattern(NounExpr(@name) @guardScope) -> StaticScope(varNames=[name]).add(guardScope)
BindingPattern(NounExpr(@name)) -> StaticScope(varNames=[name])
ListPattern(@patternScopes null) -> union(StaticScope(), patternScopes)
ViaPattern(@exprScope @patternScope) -> exprScope.add(patternScope)


Object(@doco @nameScope
       Script(@extends @implementScopes
              @methodScopes @matchers)) -> nameScope.add(union(implementsScopes + methodScopes + matcherScopes,
                                                               StaticScope()))
Method(@doco @verb @paramsScope @guardScope @blockScope) -> union(paramsScope + [guardScope, blockScope.hide()],
                                                                  StaticScope()).hide()
Matcher(@patternScope @blockScope) -> patternScope.add(blockScope).hide()

If(@testScope @consqScope @altScope) -> testScope.add(consqScope).hide().add(altScope).hide()
KernelTry(@tryScope @patternScope @catchScope) -> tryScope.hide().add(patternScope.add(catchScope)).hide()
Finally(@tryScope @finallyScope) -> tryScope.hide().add(finallyScope).hide()
Escape(@ejScope @bodyScope Catch(@argScope @catcherScope)) -> ejScope.add(bodyScope).hide().add(argScope.add(catcherScope)).hide()
Escape(@ejScope @bodyScope null) -> ejScope.add(bodyScope).hide()

MatchBind(maybeDelayedNode:specimen expand:pattern) -> specimen.add(pattern)

LogicalAnd(delayed:left  delayed:right) -> self.expandAndScope(left).add(self.expandAndScope(right))
LogicalAnd(delayed:left  @rightScope) -> self.expandAndScope(left).add(right)
LogicalAnd(@leftScope delayed:right) -> leftScope.add(self.expandAndScope(right))
LogicalAnd(@leftScope @rightScope) -> leftScope.add(rightScope)

LogicalOr(expand:left expand:right) -> StaticScope(left.namesRead | right.namesRead,
                                                   left.namesSet | right.namesSet,
                                                   left.metaStateExprFlag or right.metaStateExprFlag,
                                                   left.defNames | right.defNames,
                                                   left.varNames | right.varNames)

expand = :node -> scope(expand(node))
isDelayedNode :name = ?(name in ["MatchBind", "LogicalAnd", "LogicalOr"])
delayed = :node isDelayedNode(node.tag.name) -> scope(expand(node))

"""

def scope(term):
    return StaticScopeTransformer.transform(term)[0]

def mcall(noun, verb, *expr):
    return t.MethodCallExpr(t.NounExpr(noun), verb, expr)

def putVerb(verb):
    if verb == "get":
        return "put"
    elif verb == "run":
        return "setRun"
    elif verb.startswith("get"):
        return "set"+verb[3:]
    elif verb.startswith("__get"):
        return "__set"+verb[5:]

def buildQuasiExpr(pairs):
    textParts = []
    exprParts = []
    for text, expr in pairs:
        if expr:
            textParts.append("${%s}" % (len(exprParts),))
            exprParts.append(expr)
        else:
            textParts.append(text)
    return ''.join(textParts), exprParts


#implicit rules:
# data transforms to itself
# tuples transform to tuples with each item transformed
# other terms transform to terms of the same name with each arg transformed
expander = """

#no args and lowercase means this isn't automatically treated as a
#term, so we explicitly deal with it here
null = anything:t ?(t.tag.name == 'null')

nameAndString = NounExpr(:name):e -> e, name.data
     | SlotExpr(:name):e -> e, '&' + name.data
     | BindingExpr(:name):e -> e, '&&' + name.data

     | VarPattern(name:name :guard):p transform(p):e -> e, name
     | BindPattern(name:name :guard):p transform(p):e -> e, name
     | FinalPattern(name:name :guard):p transform(p):e -> e, name
     | SlotPattern(name:name :guard):p transform(p):e -> e, '&' + name
     | BindingPattern(name:name :guard):p transform(p):e -> e, '&&' + name

name = NounExpr(:name) -> name.data
     | SlotExpr(:name) -> '&' + name.data
     | BindingExpr(:name) -> '&&' + name.data

URIExpr(@scheme @body) -> mcall(scheme + "__uriGetter", "get", t.LiteralExpr(body))
URIGetter(@scheme) -> t.NounExpr(scheme + "__uriGetter")
MapExpr(@assocs) -> mcall("__makeMap", "fromPairs", mcall("__makeList", "run", *[mcall("__makeList", "run", *a) for a in assocs]))
MapExprAssoc(@key @value) -> [key, value]
MapExprExport(nameAndString:pair) -> [t.LiteralExpr(pair[1]), pair[0]]

ListExpr(@items) -> mcall("__makeList", "run", *items)

QuasiExpr(null quasis:qs) -> mcall(mcall("simple__quasiParser", "valueMaker", qs[0]), "substitute", qs[1])
QuasiExpr(:name quasis:qs) -> mcall(mcall(name + "__quasiParser", "valueMaker", qs[0]), "substitute", qs[1])

quasis = (qtext | qehole)*:pairs -> buildQuasiExpr(pairs)
qtext = QuasiText(:text) -> (text, None)
qehole = QuasiExprHole(@expr) -> (None, expr)

SeqExpr([]) -> None
SeqExpr([(forFx:v ~~forFx -> v)*:exprs @last]) -> t.SeqExpr(exprs + [last])

VerbCurryExpr(@receiver :verb) -> mcall("__makeVerbFacet", "curryCall", receiver, t.LiteralExpr(verb))
GetExpr(@receiver @index) -> t.MethodCallExpr(receiver, "get", index)
FunctionCallExpr(@receiver @args) -> t.MethodCallExpr(receiver, "run", args)
FunctionSendExpr(@receiver @args) -> mcall("E", "send", receiver, t.LiteralExpr("run"), args)
MethodSendExpr(@receiver :verb @args) -> mcall("E", "send", receiver, t.LiteralExpr(verb), mcall("__makeList", "run", *args))
SendCurryExpr(@receiver :verb) -> mcall("__makeVerbFacet", "currySend", receiver, t.LiteralExpr(verb))

Minus(@receiver) -> t.MethodCallExpr(receiver, "negate", [])
LogicalNot(@receiver) -> t.MethodCallExpr(receiver, "not", [])
BinaryNot(@receiver) -> t.MethodCallExpr(receiver, "complement", [])

Pow(@left @right) -> binop("pow", left, right)
Multiply(@left @right) -> binop("multiply", left, right)
Divide(@left @right) -> binop("approxDivide", left, right)
FloorDivide(@left @right) -> binop("floorDivide", left, right)
Remainder(@left @right) -> binop("remainder", left, right)
Mod(Pow(@x @y) @z) -> t.MethodCallExpr(x, "modPow", [y, z])
Mod(MethodCallExpr(@x "pow" [@y]) @z) -> t.MethodCallExpr(x, "modPow", [y, z])
Mod(@left @right) -> binop("mod", left, right)
Add(@left @right) -> binop("add", left, right)
Subtract(@left @right) -> binop("subtract", left, right)
ShiftRight(@left @right) -> binop("shiftRight", left, right)
ShiftLeft(@left @right) -> binop("shiftLeft", left, right)
Till(@left @right) -> mcall("__makeOrderedSpace", "op__till", left, right)
Thru(@left @right) -> mcall("__makeOrderedSpace", "op__thru", left, right)
GreaterThan(@left @right) -> mcall("__comparer", "greaterThan", left, right)
GreaterThanEqual(@left @right) -> mcall("__comparer", "geq", left, right)
AsBigAs(@left @right) -> mcall("__comparer", "asBigAs", left, right)
LessThanEqual(@left @right) -> mcall("__comparer", "leq", left, right)
LessThan(@left @right) -> mcall("__comparer", "lessThan", left, right)
Coerce(@spec @guard) -> t.MethodCallExpr(mcall("Guard", "coerce", guard, t.NounExpr("null")), "coerce", [spec, t.NounExpr("null")])

MatchBind(@spec @patt) = matchBind_forValue(spec patt)
Mismatch(@spec @patt) = matchBind_forValue(spec patt):expr -> t.MethodCallExpr(expr, "not", [])

Same(@left @right) -> mcall("__equalizer", "sameEver", left, right)
NotSame(@left @right) -> t.MethodCallExpr(mcall("__equalizer", "sameEver", left, right), "not", [])

ButNot(@left @right) -> binop("butNot", left, right)
BinaryOr(@left @right) -> binop("or", left, right)
BinaryAnd(@left @right) -> binop("and", left, right)
BinaryXor(@left @right) -> binop("xor", left, right)

LogicalAnd(:left :right) -> expandLogicalAnd_forValue(left, right, self.scope)
LogicalOr(:left :right) -> expandLogicalOr_forValue(left, right, self.scope)

Def(@pattern @exit @expr) -> expandDef(pattern, exit, expr)

Forward(@name) !(mktemp(name.data + "__Resolver")):rname -> t.SeqExpr([
                                            t.Def(t.ListPattern([
                                                      t.FinalPattern(name, None),
                                                      t.FinalPattern(rname, None)],
                                                  None),
                                            None,
                                          mcall("Ref", "promise")),
                                        rname])

Assign(@left @right) = ass(left right)
ass NounExpr(@name) :right -> t.Assign(t.NounExpr(name), right)
ass MethodCallExpr(@receiver @verb @args):left :right !(mktemp("ares")):ares -> t.SeqExpr([t.MethodCallExpr(receiver, putVerb(verb), args + [t.Def(t.FinalPattern(ares, None), None, right)]), ares])
ass :left :right -> err("Assignment can only be done to nouns and collection elements", self)


VerbAssign(:verb @target @args) = vass(verb target args)

vass :verb NounExpr(@name) :args -> t.Assign(t.NounExpr(name), mcall(name, verb, *args))
vass :verb MethodCallExpr(@receiver :methVerb :methArgs) :args -> expandCallVerbAssign(verb, args, receiver, methVerb, methArgs)
vass :verb :badTarget :args -> verbAssignError(badTarget, self)

AugAssign(:op :left :right) -> self.apply("transform", t.VerbAssign(binops[op], left, right))

Break(null) -> mcall("__break", "run")
Break(@expr) -> mcall("__break", "run", expr)

Continue(null) -> mcall("__continue", "run")
Continue(@expr) -> mcall("__continue", "run", expr)

Return(null) -> mcall("__return", "run")
Return(@expr) -> mcall("__return", "run", expr)

Guard(:expr :subscripts) -> expand(reduce(lambda e, s: t.GetExpr(e, s), subscripts.args, expr))

#IgnorePattern(@guard) -> t.IgnorePattern(guard)

SamePattern(@value) -> t.ViaPattern(mcall("__is", "run", value), t.IgnorePattern(None))

#VarPattern(@name @guard) -> t.VarPattern(name, guard)

BindPattern(@name @guard) -> t.ViaPattern(mcall("__bind", "run", [name.args[0].data + "__Resolver", guard]), t.IgnorePattern(None))

#FinalPattern(@name @guard) -> t.FinalPattern(name, guard)

#SlotPattern(@name @guard) -> t.SlotPattern(name, guard)

MapPattern(@assocs @tail) -> foldr(lambda more, (l, r): t.ViaPattern(l, t.ListPattern([r, more], None)),
                                   tail or t.IgnorePattern(t.NounExpr("__Empty")),
                                   reversed(assocs))

MapPatternAssoc(@key @value) -> [key, value]
MapPatternImport(nameAndString:nameAnd) -> [t.LiteralExpr(nameAnd[1]), nameAnd[0]]
MapPatternOptional(@assoc @default) -> [mcall("__extract", "depr", assoc[0], default), assoc[1]]
MapPatternRequired(@assoc) -> (mcall("__extract", "run", assoc[0]), assoc[1])
ListPattern(@patterns null) -> t.ListPattern(patterns, None)
ListPattern(@patterns @tail) -> t.ViaPattern(mcall("__splitList", "run", t.LiteralExpr(len(patterns))), patterns)

SuchThatPattern(@pattern @expr) -> t.ViaPattern(t.NounExpr("__suchThat"),
                                      t.ListPattern([pattern, t.ViaPattern(mcall("__suchThat", "run", expr))], None))

Interface(@doco nameAndString:nameAnd @guard @extends @implements InterfaceFunction(:params :resultGuard)) = interface(doco nameAnd[0] nameAnd[1] guard extends implements [transform(t.MessageDesc("", "to", params, resultGuard))])
Interface(@doco nameAndString:nameAnd @guard @extends @implements @script) = interface(doco nameAnd[0] nameAnd[1] guard extends implements script)

interface(:doco :name :nameStr :guard :extends :implements :script) -> t.Def(name, None, t.HideExpr(mcall("__makeProtocolDesc", "run", doco and t.LiteralExpr(doco), t.MethodCallExpr(t.MethodCallExpr(t.Meta("context"), "getFQNPrefix", []), "add", [t.LiteralExpr(nameStr + "__T")]), mcall("__makeList", "run", *extends), mcall("__makeList", "run", *implements), mcall("__makeList", "run", *script))))

MessageDesc(@doco @type @verb @paramDescs @guard) -> t.HideExpr(mcall("__makeMessageDesc", "run", doco and t.LiteralExpr(doco), t.LiteralExpr(verb), mcall("__makeList", "run", *paramDescs), guard or t.NounExpr("void")))

ParamDesc(name:name @guard) -> mcall("__makeParamDesc", "run", t.LiteralExpr(name), guard or t.NounExpr("any"))

Object(:doco BindPattern(:name :guard):bp :script):o transform(bp):exName
    transform(t.Object(doco, t.FinalPattern(t.NounExpr(name), None), script)):exObj
 -> t.Def(exName, None, t.HideExpr(exObj))

Object(@doco @name Function(@params @guard @implements @block))
    -> t.Object(doco, name, None, t.Script(None, implements,
                                      [t.Method(doco, "run", params, guard,
                                           t.Escape(t.FinalPattern(t.NounExpr("__return"), None),
                                               t.SeqExpr([block, t.NounExpr("null")]), None))],
                                      []))

Object(@doco @name Script(null @guard @implements @methods @matchers)) -> t.Object(doco, name, t.Script(None, guard, implements, methods, matchers))

Object(@doco VarPattern(:name :guard):vp Script(@extends @guard @implements @methods @matchers)) transform(vp):exVP
    objectSuper(doco exVP extends guard implements methods matchers [t.SlotExpr(name.args[0].data)]):o
    -> t.SeqExpr([t.Def(t.SlotPattern(name, None), None, o), name])

Object(@doco @name Script(@extends @guard @implements @methods @matchers)) =
    objectSuper(doco name extends guard implements methods matchers []):o -> t.Def(name, None, o)

objectSuper :doco :name :extends :guard :implements :methods :matchers :maybeSlot !(mktemp("pair")):p -> t.HideExpr(t.SeqExpr([
       t.Def(t.FinalPattern(t.NounExpr("super"), None),
           None, extends),
       t.Object(doco, name,
           t.Script(None, guard, methods, implements, methods,
               matchers + [t.Matcher(t.FinalPattern(p, None),
                           mcall("E", "callWithPair", t.NounExpr("super"), p))]))
       ] + maybeSlot))

matchBind_forValue :spec :patt = !(getExports(scope(spec), self.scope)):exports (
    ?(1 <= len(exports)) !(mktemp("sp")):sp -> t.SeqExpr([t.Def(t.FinalPattern(sp, None), None, spec),
                                                          expand(t.MatchBind(sp, patt), self.scope)])
    | -> delayed_forValue(t.MatchBind(spec, patt), self.scope))
matchBind_forFxOnly :spec :patt :exports !(getExports(scope(spec))):exports (
    ?(exports) !(mktemp("sp")):sp -> t.SeqExpr([t.Def(t.FinalPattern(sp, None),
                                                      None, spec),
                                                expandForFxOnly(
                                                    t.MatchBind(sp, patt),
                                                    self.scope)])
    | -> defaultFxOnlyExpander(self.scope))

matchBind_forControl :spec :patt :ej -> t.Def(patt, ej, spec)


"""

def binop(name, left, right):
    return t.MethodCallExpr(left, name, [right])


binops =  {"Add": "add",
           "Subtract": "subtract",
           "Multiply": "multiply",
           "Divide": "approxDivide",
           "Remainder": "remainder",
           "Mod": "mod",
           "Pow": "pow",
           "FloorDivide": "floorDivide",
           "ShiftRight": "shiftRight",
           "ShiftLeft": "shiftLeft",
           "BinaryAnd": "and",
           "BinaryOr": "or",
           "BinaryXor": "xor",
           "ButNot": "butNot",
           }

def expand(term, scope=None):
    g = Expander([term])
    g.scope = scope
    return g.apply("transform")[0]

def expandForFxOnly(term, scope=None):
    g = FxOnlyExpander([term])
    g.scope = scope
    return g.apply("transform")

def expandForControl(term, scope=None):
    g = ControlExpander([term])
    g.scope = scope
    return g.apply("transform")

counter = 0
def mktemp(name):
    global counter
    counter += 1
    return t.TempNounExpr(name, counter)


StaticScopeTransformer = TreeTransformerGrammar.makeGrammar(
    computeStaticScopeRules, globals(), "StaticScopeTransformer",
    superclass=TreeTransformerBase)

Expander = TreeTransformerGrammar.makeGrammar(
    expander, globals(), name="EExpander", superclass=TreeTransformerBase)