Instructions:
(desc format: "valStackBefore, handlerStackBefore =>
               valStackAfter, handlerStackAfter")

Stack manipulation
------------------
OP_DUP
  [x],[] => OP_DUP => [x, x],[]

OP_ROT
  [x, y, z],[] => OP_ROT => [y, z, x],[]

OP_POP
  [x],[] => OP_POP => [],[]

OP_SWAP
  [x, y],[] => OP_SWAP => [y, x],[]

Frame manipulation
------------------

#Assign a value to the slot at position i. Equivalent to slot.put(rValue).
OP_ASSIGN_FRAME i
OP_ASSIGN_LOCAL i
OP_ASSIGN_OUTER i
  [rValue],[] => (OP_ASSIGN+addrMode)(i) => [],[]

# Bind the top value of the stack to a local final slot at position i.
OP_BIND i
  [rValue],[] => OP_BIND(i) => [],[]

# Bind the top value of the stack as a local slot at position i.
OP_BINDSLOT i
  [slot],[] => OP_BINDSLOT(index) => [],[]

# Retrieve the slot at position i.
OP_SLOT_FRAME i
OP_SLOT_LOCAL i
OP_SLOT_OUTER i
  [],[] => (OP_SLOT+addrMode(index) => [slot],[]

# Retrieve the value at position i. Equivalent to slot.get().
OP_NOUN_FRAME i
OP_NOUN_LOCAL i
OP_NOUN_OUTER i
  [],[] => (OP_NOUN+addrMode)(i) => [value],[]

Patterns
--------

OP_LIST_PATT n
  [optEjector, specimen],[] => OP_LIST_PATT(n) =>
  [optEjector, specimen[n-1], ... optEjector, specimen[0]],[]

Literals
--------

OP_LITERAL addr
  [],[] => OP_LITERAL(addr) => [result],[]
  # Loads a literal from the constant pool.


Objects
-------
OP_BINDOBJECT scriptAddr slotAddr
  #scriptAddr is an index into the script pool
  #slotAddr is an index into locals
  #XXX work out how script pool works wrt imports etc

  #Creates an object from instance vars and auditors, then bind a FinalSlot to
  #it.
  [ivars..., auditors...],[] => OP_BINDOBJECT(addr) => [object],[]

OP_VAROBJECT scriptAddr slotAddr
  #Same as OP_BINDOBJECT except it binds a VarSlot instead.

  [ivars..., auditors...],[] => OP_VAROBJECT(addr) => [object],[]

OP_SCOPE
  [],[] => OP_SCOPE => [scope],[]

#OP_SEND verb arity
# #verb is an index into the constant pool
# [recip, args...],[] => OP_SEND(verb, arity) => [result],[]

#OP_SEND_ONLY verb arity
#  #verb is an index into the constant pool
#  [recip, args...],[] => SEND_ONLY(verb, arity) => [],[]


Control flow
------------
OP_EJECTOR_ONLY label
  [],[] => OP_EJECTOR_ONLY(label) => [ejector],[handler]
  [...],[...] => ejector(_) => [],[]
  #Generated at least by the if and escape expressions.

  #Creates/pushes an ejector on the operand stack, and creates/pushes
  #its corresponding handler onto the handler stack. The ejector, when
  #called, if it's still enabled, will ignore its argument, pop both
  #stacks to the height when the ejector was created/pushed, disable
  #itself, and branch to the label.

  #This is a /handler-introducing op/, so it must be balanced by an
  #OP_END_HANDLER which occurs at the same operand stack height, and
  #with the created/pushed handler at the top of the handler
  #stack. The label must be to code outside the handled region.

OP_EJECTOR label
  [],[] => OP_EJECTOR(label) => [ejector],[handler]
  [...],[...] => ejector(result) => [result],[]
  #Generated by the escape expression.

  #Creates/pushes an ejector on the operand stack, and creates/pushes
  #its corresponding handler onto the handler stack. The ejector, when
  #called, if it's still enabled, will pop both stacks to the height
  #when the ejector was created/pushed, disable itself, push its
  #argument, and branch to the label.

  #As with {@link #OP_EJECTOR_ONLY}, this is a handler-introducing op.

OP_TRY label
  [],[] => OP_TRY(label) => [],[handler]
  [...],[...] => handler(arg) => [arg],[]
  [...],[...] => handler.drop(pc) => [...],[...]
  #Generated by the try/catch expression.

  #Creates and pushes onto the handler stack a problem handler. This
  #handler, when dropped, does nothing. This handler, when invoked,
  #truncates the stacks to their height when the handler was
  #created/pushed, pushes its argument onto the operand stack, and
  #jumps to label.

  #As with OP_EJECTOR_ONLY, this is a handler-introducing op.

OP_UNWIND label
  [],[] => OP_UNWIND(label) => [],[handler]
  [...],[...] => handler(arg) => [rethrower(arg)],[]
  [...],[...] => handler.drop(pc) => [returner(pc)],[]
  #Generated by the try/finally expression.

  #Creates and pushes onto the handler stack a problem handler. This
  #handler, when invoked, truncates the stacks to their height when
  #the handler was created/pushed, pushes a rethrower of the arg on to
  #the operand stack, and jumps to label. A rethrower is an ejector
  #which will pop and rethrow its arg by invoking the top handler on
  #the handler stack.

  #This handler, when dropped, pushes a returner for the current pc.
  #A returner is an ejector that jumps to its pc.

  #E code can never get its hands on a rethrower or a returner. Unlike
  #some other ejectors, these are not reified in the language.

  #As with OP_EJECTOR_ONLY, this is a handler-introducing op.

OP_END_HANDLER
  [],[handler] => OP_END_HANDLER => [],[]
  #Drops the top handler on the handler stack. This is the closing
  #bracket that balances an opening handler-introducing op.

OP_BRANCH
  [optEjector, flag],[] => OP_BRANCH => [],[]

  #Coerces flag to a boolean. If it's:
  #  - true, then we fall through -- continue with the next
  #    instruction, pushing nothing.
  #  - false, then exit abruptly according to optEjector.
  #  - otherwise, the top handler on the stack is invoked to deal with
  #    the coercion failure.

OP_CALL selector
  #selector is an index into the selector pool.
  [recip, args...],[] => OP_CALL(selector) => [result],[]

OP_JUMP label
  [],[] => OP_JUMP(label) => [],[]
  #Stacks at addr must be the same as here.  A label is represented by
  #an integer offset from the position after this instruction to the
  #position of the target instruction.


Crazy junk
----------

OP_SIMPLEVARSLOT
[rValue],[] => [simpleVarSlot],[]
#Take a value and produce a var slot object containing it.

OP_GUARDEDVARSLOT
[guard, optEjector, rValue],[] => [simpleVarSlot],[]
#Take a value and produce a var slot object containing it, after
#coercing it with a guard. If coercion fails, call the ejector, if
#present.

OP_COERCETOSLOT
[rValue, optEjector],[] => [slot],[]
#Coerce a value to a Slot. If coercion fails, call the ejector, if
#present.
