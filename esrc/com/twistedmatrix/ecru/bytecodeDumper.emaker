
def toHexString
try {
  (1.0).toHexString()
  bind toHexString(f) {return f.toHexString()}
 } catch _ {
  bind toHexString := <import:com.twistedmatrix.ecru.makeFloatHexer>.toHexString
    }

def byte := 0..255

def zze(val :int) {
  if (val < 0) {
    return ((val * 2) ^ -1) | 1
  } else {
    return val * 2
  }
}

def dumpVarint(var value :int, target) {
  if (value == 0) {
    target.push(0)
    return;
  }
  while (value > 0) {
    def chunk := value & 0x7f
    value >>= 7
    if (value > 0) {
      target.push(chunk | 0x80)
    } else {
      target.push(chunk)
    }
  }
}

def dumpIntegerField(value, fieldnum, target) {
  dumpVarint(fieldnum << 3, target)
  dumpVarint(value, target)
}

def dumpStringField(string :String, fieldnum, target) {
  dumpVarint((fieldnum << 3) | 2, target)
  def buf := string.getBytes()
  dumpVarint(buf.size(), target)
  target.append(buf)
}

def dumpHexFloatField(f :float64, fieldnum, target) {
  dumpVarint((fieldnum << 3) | 2, target)
  def repr := toHexString(f).getBytes()
  dumpVarint(repr.size(), target)
  target.append(repr)
}

def dumpBignum(n, fieldnum, target) {
  def bytes := n.toByteArray()
  def size := bytes.size()
  if (size > 0xFFFF) {
    throw(`come on, $n is way too big, be serious`)
  }
  dumpVarint((fieldnum << 3) | 2, target)
  dumpVarint(size, target)
  for b in bytes {
    if (b < 0) {
      target.push(b + 256)
    } else {
      target.push(b)
    }
  }
}

def dumpCode(code, fieldnum, target) {
  dumpVarint((fieldnum << 3) | 2, target)
  dumpVarint(code.size(), target)
  target.append(code)
}

def dumpSubMessage(func, fieldnum, target) {
    dumpVarint((fieldnum << 3) | 2, target)
    def buf := [].diverge()
    func(buf)
    dumpVarint(buf.size(), target)
    target.append(buf)
}

def dumpHTable(htable, fieldnum, target) {
  for entry in htable {
    dumpSubMessage(fn buf {
      var range := entry[3].getEdges()
      for i => x in entry(0,3) + [range[0], range[1]-1] {
        dumpIntegerField(x, i+1, buf)
      }
    }, fieldnum, target)
  }
}

def dumpMethod(bits, name, target) {
  def [htable, code, numLocals] := bits
  dumpIntegerField(numLocals, 1, target)
  dumpHTable(htable, 2, target)
  dumpStringField(name, 3, target)
  dumpCode(code, 4, target)
}

def dumpMatcher([pattTable, patt, bodyTable, body, numLocals],  target) {
  dumpIntegerField(numLocals, 1, target)
  dumpHTable(pattTable, 2, target)
  dumpHTable(bodyTable, 3, target)
  dumpCode(patt, 4, target)
  dumpCode(body, 5, target)
}


def dumpScript(script, target) {
  def [meths, matchers, numSlots] := script
  dumpIntegerField(numSlots, 1, target)
  for m in meths.getKeys() {
    dumpSubMessage(fn buf {
      dumpMethod(meths[m], `${m[0]}/${m[1]}`, buf)
    }, 2, target)
  }
  for i in 0..!matchers.size() {
    dumpSubMessage(fn buf {
      dumpMatcher(matchers[i], buf)
    }, 3, target)
  }
}

def dumpSelector(sel, target) {
  dumpStringField(sel[0], 1, target)
  dumpIntegerField(sel[1], 2, target)
}

def [INTEGER, STRING, HEXFLOAT64, BIGNUM, CHARACTER] := [0, 1, 2, 3, 4]
def dump {
  to run(bytecode) {
    def constants := bytecode.getConstants()
    def selectors := bytecode.getSelectors()
    def code := bytecode.getCode()
    def scripts := bytecode.getScripts()
    def result := [].diverge()

    def dumpConstant(constant, target) {
      switch (constant) {
        match i :int {
          if (i > (2**31-1)) {
            dumpIntegerField(BIGNUM, 1, target)
            dumpBignum(i, 3, target)
          } else {
            dumpIntegerField(INTEGER, 1, target)
            dumpIntegerField(zze(i), 2, target)
          }
        }
        match s :String {
          dumpIntegerField(STRING, 1, target)
          dumpStringField(s, 3, target)
        }
        match f :float64 {
          dumpIntegerField(HEXFLOAT64, 1, target)
          dumpHexFloatField(f, 3, target)
        }
        match ch :char {
          dumpIntegerField(CHARACTER, 1, target)
          dumpIntegerField(zze(ch.asInteger()), 2, target)
        }
      }
    }


    for c in constants {
      dumpSubMessage(fn buf {
                       dumpConstant(c, buf)
                     }, 1, result)
    }
    for s in selectors {
      dumpSubMessage(fn buf {
                       dumpSelector(s, buf)
                     }, 2, result)
    }
    for script in scripts {
      dumpSubMessage(fn buf {
                       dumpScript(script, buf)
                     }, 3, result)
    }
    def htable := bytecode.getToplevelHandlerTable()
    def numLocals := bytecode.getBindings().size()
    if (code.size() > 0) {
      dumpSubMessage(fn buf {
                       dumpMethod([htable, code, numLocals], "run/0", buf)
                     }, 4, result)
    }
    return result.snapshot()
  }
  to write(bytecode, out) {
    def twist(b) {
      return if (b > 127) {
        b - 256
      } else {
        b
      }
    }
    def twistList(bs) {
      def sbs := [].diverge()
      for x in bs {
        sbs.push(twist(x))
      }
      return sbs.snapshot()
    }
    out.write(twistList(dump.run(bytecode)))
  }
}
