pragma.syntax("0.9")
def makeNoun := <elang:evm.makeSimpleNounExpr>
def makeFinalPattern := <elang:evm.makeFinalPattern>
def makeCallExpr := <elang:evm.makeCallExpr>
def makeNounExpr := <elang:evm.makeNounExpr>
def makeSeqExpr := <elang:evm.makeSeqExpr>
def makeLiteralExpr := <elang:evm.makeLiteralExpr>
def ENode := <type:org.erights.e.elang.evm.ENode>
def EExpr := <type:org.erights.e.elang.evm.EExpr>

def buildList(args :List[ENode]) {
    return makeCallExpr(null, e`__makeList`, "run", args, null)
}



def makeBuilder(name, sourceForm, optActions, grammarScope) {
    def objname := makeNounExpr(null, name, null)
    var gensymCounter := 0
    def gensym(name) {
        gensymCounter += 1
        return `_G_${name}_$gensymCounter`
    }
    def newFunction(name, expr) {
        return e__quasiParser.valueMaker(
            `def $name(ej) { return $${0} }`).substitute([expr])
    }
    def builder {

        to makeGrammar(rules) {
            def source := builder.makeGrammarSource(rules)
            if (sourceForm) {
                return source
            } else {
                def __actionObj {
                    match [verb, args] {
                        if (optActions != null &&
                            optActions.__respondsTo(verb, args.size())) {
                                E.call(optActions, verb, args)
                        } else {
                            E.call(grammarScope.get(verb), "run", args)
                        }
                    }
                }
                def scope := grammarScope.with("__actionObj", __actionObj)
                return source.eval(scope)
            }
        }

        to makeGrammarSource(rules) {
            def makerName := "make"+(name(0, 1).toUpperCase() + name(1))
            def methodTexts := [].diverge()
            var i := 0
            for name => code in rules {
                methodTexts.push(`method $name(ej) {
                    def ruleLocals := [].asMap().diverge()
                    $$$i$\n}$\n`)
                i += 1
            }
            return e__quasiParser.valueMaker(
                   `def makeOMetaBase := <import:com.twistedmatrix.ometa.makeOMetaBase>
                    def $makerName(input) {
                        def $name extends makeOMetaBase(input, $name) {$\n` +

                        "\n".rjoin(methodTexts.snapshot()) +
                       `} $\n return $name $\n}`).substitute(rules.getValues())
        }

        to apply(ruleName, args) {
            return e__quasiParser.valueMaker(
                `$name._apply("$ruleName", $${0}, ej)`
            ).substitute([buildList(args)])
        }
        to exactly(value) {
            def expr := makeLiteralExpr(null, value, null)
            return e`$objname.exactly($expr, ej)`
        }
        to many(expr) {
            def funcname := gensym("many")
            def funcnoun := makeNounExpr(null, funcname, null)
            def func := e__quasiParser.valueMaker(
                `def $funcname(ej) { return $${0} }`).substitute([expr])
            return e`$func; $objname._many($funcnoun)`
        }

        to many1(expr) {
            def funcname := gensym("many1")
            def funcnoun := makeNounExpr(null, funcname, null)
            def func := newFunction(funcname, expr)
            return e`$func; $objname._many1($funcnoun, ej)`
        }

        to optional(expr) {
            return builder.or([expr, e`null`])
        }

        to or(exprs) {
            def funcs := [].diverge()
            def names := [].diverge()
            for expr in exprs {
                def name := gensym("or")
                names.push(makeNounExpr(null, name, null))
                funcs.push(newFunction(name, expr))
            }
            funcs.push(e`$objname._or(${buildList(names.snapshot())}, ej)`)
            return makeSeqExpr(null, funcs.snapshot(), null)
        }

        to not(expr) {
            def name := gensym("not")
            return makeSeqExpr(
                null,
                [newFunction(name, expr),
                 e`$objname._not(${makeNounExpr(null, name, null)}, ej)`],
            null)
        }

        to lookahead(expr) {
            def name := gensym("lookahead")
            return makeSeqExpr(
                null,
                [newFunction(name, expr),
                 e`$objname._lookahead(${makeNounExpr(null, name, null)}, ej)`],
            null)
        }

        to sequence(exprs) {
            return makeSeqExpr(null, exprs, null)
        }

        to bindValue(expr, name) {
            def nameString := makeLiteralExpr(null, name, null)
            return e`ruleLocals.put($nameString, $expr)`
        }

        to pred(expr) {
            def name := gensym("pred")
            def func := e__quasiParser.valueMaker(
                `def $name() { return $${0} }`).substitute([expr])
            return e`$func;
                     $objname._pred(${makeNounExpr(null, name, null)}, ej)`
        }

        to compileAction(expr) {
            return expr
        }

        to makeActionLiteral(a) {
            return makeLiteralExpr(null, a, null)
        }

        to makeActionNoun(a) {
            def name := makeLiteralExpr(null, a, null)
            if (grammarScope.maps(a)) {
                return e`ruleLocals.fetch($name,
                         fn { ${makeNounExpr(null, a, null) }})`
            } else {
                return e`ruleLocals[$name]`
            }
        }

        to makeActionCall(verb, args) {
            return makeCallExpr(null, e`__actionObj`, verb, args, null)
        }

        to listpattern(expr) {
            def name := gensym("listpattern")
            return e`${newFunction(name, expr)};
                     $objname._listpattern(${makeNounExpr(null, name, null)},
                     ej)`
        }
    }
    return builder
}
