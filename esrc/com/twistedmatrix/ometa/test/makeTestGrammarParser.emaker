def makeTestCase := <import:com.twistedmatrix.eunit.makeTestCase>

def <ometa> := <import:com.twistedmatrix.ometa.*>
def makeGrammar := <ometa:makeGrammar>
def makeBuilder := <ometa:makeBuilder>


def makeTestGrammarParser() {
    def self extends makeTestCase(self) {

        to compile(grammar) {
            def b := makeBuilder("TestGrammar", false)
            def g := makeGrammar(grammar, b)
            return g._apply("grammar", [], throw)
        }

        /**
         Input matches can be made on literal characters.
        */
        to test_literal() {
            def g := self.compile("digit ::= '1'")
            self.assertEqual(g("1")._apply("digit", [], throw), '1')
            escape e {
                g("4")._apply("digit", [], e)
                throw("literal mismatch did not eject")
            }
        }

        /**
         Input matches can be made on escaped literal characters.
        */
        to test_escapedLiterals() {
            def g := self.compile("newline ::= '\\n'")
            self.assertEqual(g("\n")._apply("newline", [], throw), '\n')
        }

        /**
        Input matches can be made on literal integers.
        */
        to test_integers() {
            def g := self.compile("stuff ::= 17 0x1F -2")
            self.assertEqual(g([17, 0x1f, -2 ])._apply("stuff", [], throw), -2)
        }

        /**
         Input matches can be made on zero or more repetitions of a pattern.
         */
        to test_star() {
            def g := self.compile("xs ::= 'x'*")
            for input in ["", "x", "xxxxx"] {
                self.assertEqual(g(input)._apply("xs", [], throw),
                                 input.getArray().snapshot())
            }
            self.assertEqual(g("yx")._apply("xs", [], throw), [])
        }

        /**
         Input matches can be made on one or more repetitions of a pattern.
         */
        to test_plus() {
            def g := self.compile("xs ::= 'x'+")
            self.assertEqual(g("x")._apply("xs", [], throw), ['x'])
            self.assertEqual(g("xxx")._apply("xs", [], throw), ['x', 'x', 'x'])

            escape e {
                g("yx")._apply("xs", [], e)
                throw("plus mismatch did not eject")
                g("")._apply("xs", [], e)
                throw("plus mismatch did not eject")
            }

        }
        /**
         Input matches can be made on a sequence of patterns.
        */
        to test_sequencing() {
            def g := self.compile("twelve ::= '1' '2'")
            self.assertEqual(g("12")._apply("twelve", [], throw), '2');
            escape e {
                g("1")._apply("twelve", [], e)
                throw("sequence mismatch did not eject")
            }
        }

        /**
         Input matches can be made on one of a set of alternatives.
        */
        to test_alternatives() {
            def g := self.compile("digit ::= '0' | '1' | '2'")
            self.assertEqual(g("0")._apply("digit", [], throw), '0')
            self.assertEqual(g("1")._apply("digit", [], throw), '1')
            self.assertEqual(g("2")._apply("digit", [], throw), '2')
            escape e {
                g("3")._apply("digit", [], e)
                throw("Alternative mismatch did not eject")
            }
        }

        /**
         Subpatterns can be made optional.
        */
        to test_optional() {
            def g := self.compile("foo ::= 'x' 'y'? 'z'")
            self.assertEqual(g("xyz")._apply("foo", [], throw), 'z')
            self.assertEqual(g("xz")._apply("foo", [], throw), 'z')
        }

        /**
         Other productions can be invoked from within a production.
        */
        to test_apply() {
            def g := self.compile("digit ::= '0' | '1'
                                   bits ::= <digit>+")
            def input := "0110110"
            self.assertEqual(g(input)._apply("bits", [], throw),
                             input.getArray().snapshot())
        }

        /**
         Input can be matched based on its failure to match a pattern.
        */
        to test_negate() {
            def g := self.compile("foo ::= ~'0' <anything>")
            self.assertEqual(g("1")._apply("foo", [], throw), '1')
            escape e {
                g("01")._apply("foo", [], e)
                throw("Negation mismatch did not eject")
            }
        }
    }
    return self
}
