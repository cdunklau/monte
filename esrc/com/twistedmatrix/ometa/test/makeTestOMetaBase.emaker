pragma.syntax("0.9")
pragma.enable("accumulator")

def makeTestCase := <import:com.twistedmatrix.eunit.makeTestCase>
def makeOMetaBase := <import:com.twistedmatrix.ometa.makeOMetaBase>
def fail(x) { throw(`$x`) }

def makeTestOMetaBase() {
    def self extends makeTestCase(self) {
        /**
         The '_apply' method takes a rule name as a string and calls the method
         of that name.
        */
        to test_apply() {
            def g := makeOMetaBase("x", g)
            self.assertEqual(g._apply("anything", [], fail)[0], 'x')
            escape e {
                g._apply("anything", [], e)
                fail("'_apply' did not eject on failure")
            }
        }

        /**
         The '_pred' method ejects if the nullary function passed to it returns
         false, and returns true otherwise.
        */
        to test_pred() {
            def g := makeOMetaBase("", g)
            escape e {
 	        g.pred(fn e { [false, null] }, e)
                throw("pred' didn't eject")
            }
            self.assertEqual(g.pred(fn e { [true, null] }, fail)[0], true)
        }

        /**
         The '_not' method ejects if the function passed to it doesn't, and
         returns 'true' if it does.
        */
        to test_not() {
            def g := makeOMetaBase("", g)
            escape e {
                g.not(fn x { [true, null] }, e)
                throw("'_not' didn't eject")
            }
            self.assertEqual(g.not(fn e { e("done") }, fail)[0], true)
        }

        /**
         The '_lookahead' method runs the given function and returns its result,
         resetting the position in the input afterwards.
        */
        to test_lookahead() {
            def g := makeOMetaBase("x", g)
            self.assertEqual(g.lookahead(fn e { g.anything(e) }, fail)[0],
                             'x')
            self.assertEqual(g.anything(fail)[0], 'x')
            escape e {
                g.lookahead(fn e { g.anything(e) }, e)
                throw("'lookahead' did not eject")
            }
        }

        /**
           The '_or' method calls each function passed to it in turn until one
           succeeds, returning the matched value.
        */
        to test_or() {
            def attemptedMatches := [].diverge()
            def input := "ab"
            def g := makeOMetaBase(input, g)
            def makeMatcher(ch) {
                def doMatch(e) {
                    attemptedMatches.push(ch)
                    return g.exactly(ch, e)
                }
                return doMatch
            }
            def [result, err] := g._or([makeMatcher('x'), makeMatcher('y'),
                                 makeMatcher('a'), makeMatcher('z')],
                              	  fail)
            self.assertEqual(result, 'a')
            self.assertEqual(attemptedMatches.snapshot(),
                             ['x', 'y', 'a'])
            escape e {
                g._or([makeMatcher('w')], e)
                throw("'_or' refused to fail")
            } catch p {
	        self.assertEqual(p, term`error([expected('w')], input(1, 'b'))`)
            }
        }


	to test_joinErrors() {
	    def input := "xyz"
            def g := makeOMetaBase(input, g)
	    escape e {
    	        def [result, err] := g._or([fn e { g.exactly('x', e);
	                                           g.exactly('a', e) },
			    	            fn e { g.exactly('x', e);
					           g.exactly('y', e);
						   g.exactly('a', e) },
					    fn e { g.exactly('b', e) }], e)
                throw(`failed to eject`)
	    } catch p {
                self.assertEqual(p, term`error([expected('a')], input(2, 'z'))`)
            }
	}

        /**
          The '_many' method calls the function passed to it until it fails to
          match the input, collecting its return values into a list.
        */
        to test_many() {
            def input := "xxxabc"
            def g := makeOMetaBase(input, g)
            def [res, err] := g._many(fn e { g.exactly('x', e) })
            self.assertEqual(res, ['x', 'x', 'x'])
            self.assertEqual(g.exactly('a', fail)[0], 'a')

            self.assertEquals(g._many(fn e { g.exactly('z', e) })[0], [])
        }

        /**

         The '_many1' method calls the given function until it ejects. If the
         function ejects on the first call, the method calls its
         ejector. Otherwise, it collects the results into a list.
        */
        to test_many1() {
            def input := "xxxabc"
            def g := makeOMetaBase(input, g)
            def [res, err] := g._many1(fn e { g.exactly('x', e) }, fail)
            self.assertEqual(res , ['x', 'x', 'x'])
            self.assertEqual(g.exactly('a', fail)[0], 'a')

            escape e {
                g._many1(fn e { g.exactly('z', e) }, e)
                throw("'_many1' did not eject on failure")
            }
        }

        /**
         The 'anything' method matches the next item on the input and returns
         it, or ejects if the input is empty.
        */

        to test_anything() {
            def g := makeOMetaBase("xy", g)
            self.assertEqual(g.anything(fail)[0], 'x')
            self.assertEqual(g.anything(fail)[0], 'y')
            escape e {
                g.anything(e)
                throw("'anything' did not eject on failure")
            }
        }

        /**
         'end' matches the end of the input stream.
        */
        to test_end() {
            def g := makeOMetaBase("x", g)
            escape e {
                g.rule_end(e)
                throw("'end' matched before end of input")
            }
            g.anything(fail)
	    def [val, err] := g.rule_end(fail)
            self.assertEqual(val, true)
        }


        /**
         'listpattern' consumes the next item of input and treats it as an
         input stream, matching the subpattern specified against it.
        */
        to test_listpattern() {
            def input := ["fu", "fuzz"]
            def g := makeOMetaBase(input, g)
            def submatcher(ej) { g.exactly('f', ej); g.exactly('u', ej) }
            def result := g._listpattern(submatcher, fail)
            self.assertEqual(result, ["fu", term`error(null, input(0, "fu"))`])
            escape e {
                g._listpattern(submatcher, e)
                throw("'listpattern' did not eject on failure")
            }

        }

        /**
          The 'exactly' method returns the object passed to it if the
          current item of the input matches. Otherwise, it invokes the
          ejector provided, if any, or throws.
        */
        to test_exactly() {
            def input := "foo"
            def g := makeOMetaBase(input, g)
            def [result, err] := g.exactly('f', fail)
            self.assertEqual(result, 'f')
            escape e {
                g.exactly('x', e)
                throw("'exactly' did not eject on failure")
            }
            self.assertEqual(g.exactly('o', fail)[0], 'o')
        }

        /**
         The 'spaces' method consumes everything up to the next
         non-whitespace character.
        */
        to test_spaces() {
            def input := " \n\t\r   x"
            def g := makeOMetaBase(input, g)
            def [result, err] := g.spaces(fail)
            self.assertEqual(g.exactly('x', fail)[0], 'x')
        } 

        /**
         'token' matches the given string plus any preceding whitespace.
        */
        to test_token() {
            def input := "  foo baz"
            def g := makeOMetaBase(input, g)
            def [result, err] := g._apply("token", ["foo"], fail)
            self.assertEqual(result, "foo")
            escape e {
                g._apply("token", ["foo"], e)
                throw("'token' did not eject on failure")
            }
            self.assertEqual(g._apply("token", ["baz"], fail)[0], "baz")
        }
        /**
         'letter' matches letters.
        */
        to test_letter() {
            def input := "x9"
            def g := makeOMetaBase(input, g)
            def [result, err] := g.letter(fail)
            self.assertEqual(result, 'x')
            escape e {
                g.letter(e)
                throw("'letter' did not eject on failure")
            }
            self.assertEqual(g.anything(fail)[0], '9')
        }
        /**
         'digit' matches digits.
        */
        to test_digit() {
            def input := "9x"
            def g := makeOMetaBase(input, g)
            def [result, err] := g.digit(fail)
            self.assertEqual(result, '9')
            escape e {
                g.digit(e)
                throw("'digit' did not eject on failure")
            }
            self.assertEqual(g.anything(fail)[0], 'x')
        }
        /**
         'letterOrDigit' matches letters, digits, and '_'.
        */
        to test_letterOrDigit() {
            def input := "9_x@"
            def g := makeOMetaBase(input, g)
            self.assertEqual(g.letterOrDigit(fail)[0], '9')
            self.assertEqual(g.letterOrDigit(fail)[0], '_')
            self.assertEqual(g.letterOrDigit(fail)[0], 'x')
            escape e {
                g.letterOrDigit(e)
                throw("'letterOrDigit' did not eject on failure")
            }
            self.assertEqual(g.anything(fail)[0], '@')
        }
    }
    return self
}
