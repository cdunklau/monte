pragma.syntax("0.9")

def makeOMetaBase(input, self) {
    var current := input
    def ometaBase {

        /**
         Apply the named method, memoizing the result and allowing for left
         recursion.
        */
        to _apply(rule, args, ejector) {
            return E.call(self, rule, args + [ejector])
        }

        /**
         Call the given nullary function. Eject if it returns false.
        */
        to _pred(func, ejector) {
            if (!func()) {
                ejector(`predicate was false at ${current.getOptSpan()}`)
            } else {
                return true
            }
        }

        /**
         Call the given function. Eject if it does not.
        */
        to _not(func, ejector) {
            def lastInput := current
            escape e {
                try {
                    func(e)
                } finally {
                    current := lastInput
                }
            } catch p {
                return true
            }
            ejector("function in 'not' didn't eject")
        }

        /**
         Call the given function, resetting the input position afterwards.
         */
        to _lookahead(func, ejector) {
            def m := current
            try {
                return func(ejector)
            } finally {
                current := m
            }
        }

        /**
         Call each of a list of functions in sequence until one succeeds,
         rewinding the input between each.
        */
        to _or(fns, ejector) {
            var lastInput := current
            for f in fns {
                escape e {
                    lastInput := current
                    return f(e)
                } catch p {
                    current := lastInput
                }
            }
            ejector("No matches")
        }

        /**
         Common code for _many/1 and _many1/1.
        */
        to _many(func, initial) {
            var lastInput := current
            def ans := initial.diverge()
            while (true) {
                escape e {
                    lastInput := current
                    ans.push(func(e))
                } catch p {
                    current := lastInput
                    return ans.snapshot()
                }
            }
        }
        /**
         Call 'func' until it fails to match the input. Collect the resulting
         values into a list.
        */
        to _many(func) {
            return ometaBase._many(func, [])
        }

        /**
         Call 'func' until it fails to match the input, collecting the result
         into a list. Eject if it matches zero times.
         */
        to _many1(func, ejector) {
            return ometaBase._many(func, [func(ejector)])
        }

        /**
         Pattern-match the contents of the next item from the input as its own
         stream.
        */
        to _listpattern(subpattern, ejector) {
            def boringEjector := fn x { ejector(x)}
            # this is overly restrictive but I don't know a better spelling
            def v :any[List, String] exit boringEjector := (
                ometaBase.anything(ejector))
            def oldInput := current
            current := v
            subpattern(ejector)
            ometaBase._end(ejector)
            current := oldInput
            return v
        }

        /**
         Match a single item from the input.
        */
        to anything(ejector) {
            def i := current
            if (current.size() == 0) {
               ejector("at end of input")
            }
            def val := current[0]
            current := current.run(1)
            return val
        }


        /**
         Match the end of the input stream.
        */
        to _end(ejector) {
            return ometaBase._not(ometaBase.anything, ejector)
        }

        /**
         Match a single item from the input equal to the given specimen.
        */
        to exactly(wanted, ejector) {
            def original := current
            def val := ometaBase.anything(ejector)
            if (wanted == val) {
                return val
            } else {
                current := original
                ejector(`$wanted does not match $val`)
            }
        }

        /**
         Match a single character.
         */
        to char(ejector) {
            # 'fn' hack here due to EoJ unfortunateness
            def r :char exit fn x {ejector(x)} := ometaBase.anything(ejector)
            return r
        }
        /**
         Consume input until a non-whitespace character is reached.
         */
        to spaces(ejector) {
            def space(e) {
                def r := ometaBase.char(e)
                if (r > ' ') {
                    e("not a space")
                }
            }
            return ometaBase._many(space)
        }

        /**
         Consume a given string plus any leading whitespace.
        */
        to token(tok, ejector) {
            def original := current
            ometaBase.spaces(ejector)
            escape e {
                for ch in tok {
                    ometaBase.exactly(ch, e)
                }
            } catch err {
                current := original
                ejector(err)
            }
            return tok
        }
        /**
         Match a single letter.
        */
        to letter(ejector) {
            def original := current
            def x := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z')) {
                return x
            } else {
                current := original
                ejector(`not a letter: ${x.quote()}`)
            }
        }
        /**
         Match a single digit.
         */
        to digit(ejector) {
            def original := current
            def x := ometaBase.anything(ejector)
            if (x >= '0' && x <= '9') {
                return x
            } else {
                current := original
                ejector("not a digit")
            }
        }
        /**
         Match a single alphanumeric character. (and '_').
        */
        to letterOrDigit(ejector) {
            def original := current
            def x := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                (x >= '0' && x <= '9') ||
                (x == '_')) {
                return x
            } else {
                current := original
                ejector("not alphanumeric")
            }
        }
    }
    return ometaBase
}