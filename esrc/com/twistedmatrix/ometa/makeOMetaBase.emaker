pragma.syntax("0.9")

def makeFailer() {
    var used := false
    def failer {
        to setUsed() { used := true }
        to used() { return used }
        to isFailure() { return true }
    }
    return failer
}

def makeMemo(var ans, var input) {
    def memo {
        to update(newAns, newInput) { ans := newAns; input := newInput }
        to ans() { return ans }
        to input() { return input }
        to isFailure() { return false }
    }
    return memo
}

def makeInputStream(input, position) {
    def memo := [].asMap().diverge()
    var tail := null
    def inputStream {
        to head(ej) {
            if (input.size() == position) {
              if ((def span := input.getOptSpan()) != null) {
                ej(term`endOfInput(${span.getUrl()})`)
              } else {
                ej(term`endOfInput("*string*")`)
              }
            }
            def value := input[position]
            return [value, term`input($value, $position)`]
        }
        to tail() {
            if (tail == null) {
                tail := makeInputStream(input, position+1)
            }
            return tail
        }
        to getMemo(name) {
            return memo.fetch(name, fn { null })
        }
        to setMemo(name, rec) {
            memo[name] := rec
            return rec
        }
    }
    return inputStream
}

def makeArg(arg, current) {
    def memo := [].asMap().diverge()
    def argument {
        to head(ej) {
          return [arg, null]
        }
        to tail() {
            return current
        }
        to getMemo(name) {
            return memo.fetch(name, fn { null })
        }
        to setMemo(name, rec) {
            memo[name] := rec
            return rec
        }
    }
    return argument
}

def joinErrors(errs) { 
    def bestErrs := [].asMap().diverge()
    for err in errs {
    	switch (err) {
	    match term`expected(@_, input(@_, @where))` {
	    	bestErrs.fetch(where, fn { bestErrs[where] := [].diverge() }).push(err)
            }
	    match term`oneOf(@suberrs)` {
	        def where := suberrs[0].getArgs()[1]
	    	bestErrs.fetch(where, fn { bestErrs[where] := [].diverge() }).append(suberrs)
	    }
	    match x {
	        throw(`Unknown error structure: $x`)
	    }
	}
    }
    def idx := bestErrs.getKeys().sort().last()
    traceln(`${bestErrs[idx].size()}`)
    if (bestErrs[idx].size() == 1) {
        return bestErrs[idx][0]
    } else {
        return term`oneOf(${bestErrs[idx]})`
    }
}   

def makeOMetaBase(input, self) {
    var current := makeInputStream(input, 0)
    def ometaBase {
        /**
	 Version of _apply that strips error info for successes.
	*/
        to _run(rule, args, ejector) {
          def [val, err] := self._apply(rule, args, ejector)
          return val
        }

        /**
         Apply the named method, memoizing the result and allowing for left
         recursion.
        */
        to _apply(rule, args, ejector) {
            def name := "rule_" + rule
            if (args.size() > 0) {
                for arg in args {
                    current := makeArg(arg, current)
                }
                return E.call(self, name, [ejector])
            }
            var memoRec := current.getMemo(name)
            if (memoRec == null) {
                def origInput := current
                def failer := makeFailer()
                memoRec := current.setMemo(name, failer)

                memoRec := current.setMemo(name,
                                           makeMemo(E.call(self, name, [ejector]),
                                                    current))
                if (failer.used()) {
                    def sentinel := current
                     while (true) {
                         current := origInput
                         def ans := E.call(self, name, [ejector])
                         if (current == sentinel) {
                             break
                        }
                        memoRec.update(ans, current)
                    }
                }
            } else if (memoRec.isFailure()) {
                memoRec.setUsed()
                ejector(term`recursionErrorIGuess`)
            }
            current := memoRec.input()
            return memoRec.ans()

        }

        /**
         Call the given nullary function. Eject if it returns false.
        */
        to _pred(func, ejector) {
            if (!func()) {
                ejector(term`predicateFailed`)
            } else {
              return [true, null]
            }
        }

        /**
         Call the given function. Eject if it does not.
        */
        to _not(func, ejector) {
            def lastInput := current
            def err
            escape e {
                try {
                  def [_, bind err] := func(e)
                } finally {
                    current := lastInput
                }
            } catch p {
                return [true, null]
            }
            ejector(term`unexpected($err)`)
        }

        /**
         Call the given function, resetting the input position afterwards.
         */
        to _lookahead(func, ejector) {
            def m := current
            try {
                return func(ejector)
            } finally {
                current := m
            }
        }

        /**
         Call each of a list of functions in sequence until one succeeds,
         rewinding the input between each.
        */
        to _or(fns, ejector) {
            var lastInput := current
            def errs := [].diverge()
            for f in fns {
                escape e {
                    lastInput := current
                    return f(e)
                } catch p {
                    current := lastInput
                    errs.push(p)
                }
            }
            ejector(joinErrors(errs))
        }

        /**
         Common code for _many/1 and _many1/1.
        */
        to _many(func, initial, initialErr) {
            var lastInput := current
            def ans := initial.diverge()
            var lastErr := initialErr
            while (true) {
                escape e {
                    lastInput := current
                    def [v, err] := func(e)
                    ans.push(v)
                    lastErr := err
                } catch p {
                    current := lastInput
                    return [ans.snapshot(), lastErr]
                }
            }
        }
        /**
         Call 'func' until it fails to match the input. Collect the resulting
         values into a list.
        */
        to _many(func) {
            return ometaBase._many(func, [], null)
        }

        /**
         Call 'func' until it fails to match the input, collecting the result
         into a list. Eject if it matches zero times.
         */
        to _many1(func, ejector) {
            def [v, e] := func(ejector)
            return ometaBase._many(func, [v], e)
        }

        /**
         Pattern-match the contents of the next item from the input as its own
         stream.
        */
        to _listpattern(subpattern, ejector) {
            def boringEjector := fn x { ejector(x)}
            # this is overly restrictive but I don't know a better spelling
            def [v :any[List, String], _] exit boringEjector := (
                ometaBase.anything(ejector))
            def oldInput := current
            current := makeInputStream(v, 0)
            subpattern(ejector)
            ometaBase._end(ejector)
            current := oldInput
            return v
        }

        /**
         Match a single item from the input.
        */
        to anything(ejector) {
            def val := current.head(ejector)
            current := current.tail()
            return val
        }


        /**
         Match the end of the input stream.
        */
        to _end(ejector) {
            escape e {
              return ometaBase._not(ometaBase.anything, e)
            } catch p {
              ejector(term`expected(endOfInput, null)`)
            }
        }

        /**
         Match a single item from the input equal to the given specimen.
        */
        to exactly(wanted, ejector) {
            def original := current
            def [val, err] := ometaBase.anything(ejector)
            if (wanted == val) {
                return [val, err]
            } else {
                current := original
                ejector(term`expected(${wanted}, $err)`)
            }
        }

        /**
         Match a single character.
         */
        to char(ejector) {
            def [r, err] := ometaBase.anything(ejector)
            if (r !~ _ :char) {
                ejector(term`expected("a character", $err)`)
            }
            return [r, err]
        }
        /**
         Consume input until a non-whitespace character is reached.
         */
        to spaces(ejector) {
            def space(e) {
              def [r, err] := ometaBase.char(e)
              if (r > ' ') {
                e(term`expected("whitespace", $err)`)
              }
	      return [r, err]
            }
            return ometaBase._many(space)
        }

        /**
         Consume a given string plus any leading whitespace.
        */
        to token(ejector) {
          def [tok, _] := ometaBase.anything(ejector)
            def original := current
            ometaBase.spaces(ejector)
            var lastErr := null
            escape e {
                for ch in tok {
                  def [r, err] := ometaBase.exactly(ch, e)
                  lastErr := err
                }
            } catch err {
                current := original
                ejector(term`expected($tok, $err)`)
            }
            return [tok, lastErr]
        }
        /**
         Match a single letter.
        */
        to letter(ejector) {
            def original := current
            def [x, err] := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                x == '_') {
              return [x, err]
            } else {
                current := original
                ejector(term`expected("letter", $err)`)
            }
        }
        /**
         Match a single digit.
         */
        to digit(ejector) {
            def original := current
            def [x, e] := ometaBase.anything(ejector)
            if (x >= '0' && x <= '9') {
              return [x, e]
            } else {
                current := original
                ejector(term`expected("digit", $e)`)
            }
        }
        /**
         Match a single alphanumeric character. (and '_').
        */
        to letterOrDigit(ejector) {
            def original := current
            def [x, e] := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                (x >= '0' && x <= '9') ||
                (x == '_')) {
                return [x, e]
            } else {
                current := original
                ejector(term`expected("letter or digit", $e)`)
            }
        }

        to tokenBR(ejector) {
            def token := ometaBase.anything(ejector)
            def oldInput := current
            escape e {
                ometaBase.spaces(e)
                for ch in token {
                  def r := ometaBase.exactly(ch, e)
                }
                def [v, brErr] := ometaBase._apply("br", [], e)
                return [token, brErr]
            } catch p {
                current := oldInput
                ejector(term`expected("token followed by line break or semicolon", $p)`)
            }
        }

        to br(ejector) {}

        match [`rule_@name`, args] {
             E.call(ometaBase, name, args)
        }
    }
    return ometaBase
}