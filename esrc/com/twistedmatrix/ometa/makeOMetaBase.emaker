pragma.syntax("0.9")

def makeFailer() {
    var used := false
    def failer {
        to setUsed() { used := true }
        to used() { return used }
        to isFailure() { return true }
    }
    return failer
}

def makeMemo(var ans, var input) {
    def memo {
        to update(newAns, newInput) { ans := newAns; input := newInput }
        to ans() { return ans }
        to input() { return input }
        to isFailure() { return false }
    }
    return memo
}

def makeInputStream(input, position) {
    def memo := [].asMap().diverge()
    var tail := null
    def inputStream {
        to head(ej) {
            if (input.size() == position) {
                ej("at end of input")
            }
            return input[position]
        }
        to tail() {
            if (tail == null) {
                tail := makeInputStream(input, position+1)
            }
            return tail
        }
        to getMemo(name) {
            return memo.fetch(name, fn { null })
        }
        to setMemo(name, rec) {
            memo[name] := rec
            return rec
        }
    }
    return inputStream
}

def makeArg(arg, current) {
    def memo := [].asMap().diverge()
    def argument {
        to head(ej) {
            return arg
        }
        to tail() {
            return current
        }
        to getMemo(name) {
            return memo.fetch(name, fn { null })
        }
        to setMemo(name, rec) {
            memo[name] := rec
            return rec
        }
    }
    return argument
}

def makeOMetaBase(input, self) {
    var current := makeInputStream(input, 0)
    def ometaBase {

        /**
         Apply the named method, memoizing the result and allowing for left
         recursion.
        */
        to _apply(rule, args, ejector) {
            if (args.size() > 0) {
                for arg in args {
                    current := makeArg(arg, current)
                }
                def result := E.call(self, rule, [ejector])
                return result
            }
            var memoRec := current.getMemo(rule)
            if (memoRec == null) {
                def origInput := current
                def failer := makeFailer()
                memoRec := current.setMemo(rule, failer)

                memoRec := current.setMemo(rule,
                                           makeMemo(E.call(self, rule, [ejector]),
                                                    current))
                if (failer.used()) {
                    def sentinel := current
                     while (true) {
                         current := origInput
                         def ans := E.call(self, rule, [ejector])
                         if (current == sentinel) {
                             break
                        }
                        memoRec.update(ans, current)
                    }
                }
                #current := origInput
            } else if (memoRec.isFailure()) {
                memoRec.setUsed()
                ejector("application failed")
            }
            current := memoRec.input()
            return memoRec.ans()

        }

        /**
         Call the given nullary function. Eject if it returns false.
        */
        to _pred(func, ejector) {
            if (!func()) {
                ejector(`predicate was false`)
            } else {
                return true
            }
        }

        /**
         Call the given function. Eject if it does not.
        */
        to _not(func, ejector) {
            def lastInput := current
            escape e {
                try {
                    func(e)
                } finally {
                    current := lastInput
                }
            } catch p {
                return true
            }
            ejector("function in 'not' didn't eject")
        }

        /**
         Call the given function, resetting the input position afterwards.
         */
        to _lookahead(func, ejector) {
            def m := current
            try {
                return func(ejector)
            } finally {
                current := m
            }
        }

        /**
         Call each of a list of functions in sequence until one succeeds,
         rewinding the input between each.
        */
        to _or(fns, ejector) {
            var lastInput := current
            for f in fns {
                escape e {
                    lastInput := current
                    return f(e)
                } catch p {
                    current := lastInput
                }
            }
            ejector("No matches")
        }

        /**
         Common code for _many/1 and _many1/1.
        */
        to _many(func, initial) {
            var lastInput := current
            def ans := initial.diverge()
            while (true) {
                escape e {
                    lastInput := current
                    ans.push(func(e))
                } catch p {
                    current := lastInput
                    return ans.snapshot()
                }
            }
        }
        /**
         Call 'func' until it fails to match the input. Collect the resulting
         values into a list.
        */
        to _many(func) {
            return ometaBase._many(func, [])
        }

        /**
         Call 'func' until it fails to match the input, collecting the result
         into a list. Eject if it matches zero times.
         */
        to _many1(func, ejector) {
            return ometaBase._many(func, [func(ejector)])
        }

        /**
         Pattern-match the contents of the next item from the input as its own
         stream.
        */
        to _listpattern(subpattern, ejector) {
            def boringEjector := fn x { ejector(x)}
            # this is overly restrictive but I don't know a better spelling
            def v :any[List, String] exit boringEjector := (
                ometaBase.anything(ejector))
            def oldInput := current
            current := makeInputStream(v, 0)
            subpattern(ejector)
            ometaBase._end(ejector)
            current := oldInput
            return v
        }

        /**
         Match a single item from the input.
        */
        to anything(ejector) {
            def val := current.head(ejector)
            current := current.tail()
            return val
        }


        /**
         Match the end of the input stream.
        */
        to _end(ejector) {
            return ometaBase._not(ometaBase.anything, ejector)
        }

        /**
         Match a single item from the input equal to the given specimen.
        */
        to exactly(wanted, ejector) {
            def original := current
            def val := ometaBase.anything(ejector)
            if (wanted == val) {
                return val
            } else {
                current := original
                ejector(`$wanted does not match $val`)
            }
        }

        /**
         Match a single character.
         */
        to char(ejector) {
            # 'fn' hack here due to EoJ unfortunateness
            def r :char exit fn x {ejector(x)} := ometaBase.anything(ejector)
            return r
        }
        /**
         Consume input until a non-whitespace character is reached.
         */
        to spaces(ejector) {
            def space(e) {
                def r := ometaBase.char(e)
                if (r > ' ') {
                    e("not a space")
                }
            }
            return ometaBase._many(space)
        }

        /**
         Consume a given string plus any leading whitespace.
        */
        to token(ejector) {
            def tok := ometaBase.anything(ejector)
            def original := current
            ometaBase.spaces(ejector)
            escape e {
                for ch in tok {
                    ometaBase.exactly(ch, e)
                }
            } catch err {
                current := original
                ejector(err)
            }
            return tok
        }
        /**
         Match a single letter.
        */
        to letter(ejector) {
            def original := current
            def x := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                x == '_') {
                return x
            } else {
                current := original
                ejector(`not a letter: ${x.quote()}`)
            }
        }
        /**
         Match a single digit.
         */
        to digit(ejector) {
            def original := current
            def x := ometaBase.anything(ejector)
            if (x >= '0' && x <= '9') {
                return x
            } else {
                current := original
                ejector("not a digit")
            }
        }
        /**
         Match a single alphanumeric character. (and '_').
        */
        to letterOrDigit(ejector) {
            def original := current
            def x := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                (x >= '0' && x <= '9') ||
                (x == '_')) {
                return x
            } else {
                current := original
                ejector("not alphanumeric")
            }
        }

        to tokenBR(ejector) {
            def token := ometaBase.anything(ejector)
            def oldInput := current
            escape e {
                ometaBase.spaces(e)
                for ch in token {
                    ometaBase.exactly(ch, e)
                }
                ometaBase._apply("br", [], e)
                return token
            } catch p {
                current := oldInput
                ejector(p)
            }
        }

        to br(ejector) {}
    }
    return ometaBase
}