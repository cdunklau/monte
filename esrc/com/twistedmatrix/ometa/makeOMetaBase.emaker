pragma.syntax("0.9")

def makeFailer() {
    var used := false
    def failer {
        to setUsed() { used := true }
        to used() { return used }
        to isFailure() { return true }
    }
    return failer
}

def makeMemo(var ans, var input) {
    def memo {
        to update(newAns, newInput) { ans := newAns; input := newInput }
        to ans() { return ans }
        to input() { return input }
        to isFailure() { return false }
    }
    return memo
}

def makeInputStream(input, position) {
    def memo := [].asMap().diverge()
    def value := input.fetch(position, fn { null })
    var tail := null
    def inputStream {
        to head(ej) {
            if (input.size() == position) {
                ej(term`error([endOfInput], input($position, null))`)
            }
            def value := input[position]
            return [value, inputStream.error(null)]
        }
        to tail() {
            if (tail == null) {
                tail := makeInputStream(input, position+1)
            }
            return tail
        }
        to getMemo(name) {
            return memo.fetch(name, fn { null })
        }
        to setMemo(name, rec) {
            memo[name] := rec
            return rec
        }

	to getPosition() {
	  return position
	}

        to error(var reason) {
            if (reason != null) { reason := [reason] }
            return term`error($reason, input($position, $value))`
        }
    }
    return inputStream
}

def makeArg(arg, position, current) {
    def memo := [].asMap().diverge()
    def argument {
        to head(ej) {
          return [arg, null]
        }
        to tail() {
            return current
        }
        to getMemo(name) {
            return memo.fetch(name, fn { null })
        }
        to setMemo(name, rec) {
            memo[name] := rec
            return rec
        }
        to error(var reason) {
            if (reason != null) { reason := [reason] }
            return term`error($reason, input($position, $arg))`
        }
        to getPosition() {
            return position
        }
    }
    return argument
}

def joinErrors(errorTerms) {
    def bestErrs := [].asMap().diverge()
    for err ? (err != null) in errorTerms {
        def term`error(@_, input(@where, @_))` := err
        bestErrs.fetch(where, fn { bestErrs[where] := [].diverge() }).push(err)
    }
    if (bestErrs.size() == 0) {
      return null
    }
    def idx := bestErrs.getKeys().sort().last()
    def bestList := bestErrs[idx]
    if (bestList.size() == 1) {
        return bestList[0]
    } else {
      var reasons := [].asSet()
        def term`error(@_, @pos)` := bestList[0]
        for err in bestList {
            if (err =~ term`error([@subReasons*], @_)`) {
	      reasons |= subReasons.asSet()
            }
        }
        return term`error(${reasons.getElements().sort()}, $pos)`
    }
}

def makeOMetaBase(input, self) {
    var current := makeInputStream(input, 0)
    var currentError := current.error(null)
    def ometaBase {

        to getCurrentError() {
            return currentError
        }

	to getInput() {
	  return current
	}

        /**
	 Version of _apply that strips error info for successes.
	*/
        to _run(rule, args, ejector) {
          def [val, err] := self._apply(rule, args, ejector)
          return val
        }

        /**
         Apply the named method, memoizing the result and allowing for left
         recursion.
        */
        to _apply(rule, args, ejector) {
            def name := "rule_" + rule
            if (args.size() > 0) {
	      for arg in args {
		current := makeArg(arg, current.getPosition(), current)
                }
                return E.call(self, name, [ejector])
            }
            var memoRec := current.getMemo(name)
            if (memoRec == null) {
                def origInput := current
                def failer := makeFailer()
                memoRec := current.setMemo(name, failer)

                memoRec := current.setMemo(name,
                                           makeMemo(E.call(self, name, [ejector]),
                                                    current))
                if (failer.used()) {
                    def sentinel := current
                     while (true) {
                         current := origInput
                         def ans := E.call(self, name, [ejector])
                         if (current == sentinel) {
                             break
                        }
                        memoRec.update(ans, current)
                    }
                }
            } else if (memoRec.isFailure()) {
                memoRec.setUsed()
                ejector(current.error(null))
            }
            current := memoRec.input()
            return memoRec.ans()

        }

        /**
         Call the given nullary function. Eject if it returns false.
        */
        to pred(func, ejector) {
            if (!func(ejector)[0]) {
	      ejector(current.error(term`predicateFailed`))
            } else {
              return [true, null]
            }
        }

        /**
         Call the given function. Eject if it does not.
        */
        to not(func, ejector) {
            def lastInput := current
            def err
            escape e {
                try {
                  def [_, bind err] := func(e)
                } finally {
                    current := lastInput
                }
            } catch p {
                return [true, null]
            }
            ejector(current.error(null))
        }

        /**
         Call the given function, resetting the input position afterwards.
         */
        to lookahead(func, ejector) {
            def m := current
            try {
                return func(ejector)
            } finally {
                current := m
            }
        }

        /**
         Call each of a list of functions in sequence until one succeeds,
         rewinding the input between each.
        */
        to _or(fns, ejector) {
            var lastInput := current
            def errs := [].diverge()
            for f in fns {
                escape e {
                    lastInput := current
                    def [v, err] := f(e)
		    errs.push(err)
		    return [v, joinErrors(errs)]
                } catch p {
                    current := lastInput
                    errs.push(p)
                }
            }
            ejector(joinErrors(errs))
        }

        /**
         Common code for _many/1 and _many1/1.
        */
        to _many(func, [initial, initialErr]) {
            var lastInput := current
            def ans := initial.diverge()
            var lastErr := initialErr
            while (true) {
                escape e {
                    lastInput := current
                    def [v, err] := func(e)
                    ans.push(v)
                    lastErr := err
                } catch p {
                    current := lastInput
                    return [ans.snapshot(), lastErr]
                }
            }
        }
        /**
         Call 'func' until it fails to match the input. Collect the resulting
         values into a list.
        */
        to _many(func) {
            return ometaBase._many(func, [[], null])
        }

        /**
         Call 'func' until it fails to match the input, collecting the result
         into a list. Eject if it matches zero times.
         */
        to _many1(func, ejector) {
            def [v, e] := func(ejector)
            return ometaBase._many(func, [[v], e])
        }

        /**
         Pattern-match the contents of the next item from the input as its own
         stream.
        */
        to _listpattern(subpattern, ejector) {
            def boringEjector := fn x { ejector(current.error(term`listPatternMismatch`)) }
            # this is overly restrictive but I don't know a better spelling
            def [v :any[List, String], e] exit boringEjector := (
                ometaBase.anything(ejector))
            def oldInput := current
            current := makeInputStream(v, 0)
            subpattern(ejector)
            ometaBase._end(ejector)
            current := oldInput
            return [v, e]
        }

        /**
         Match a single item from the input.
        */
        to anything(ejector) {
            def val := current.head(ejector)
            current := current.tail()
            return val
        }


        /**
         Match the end of the input stream.
        */
        to _end(ejector) {
            return ometaBase.not(ometaBase.anything, ejector)
        }

        /**
         Match a single item from the input equal to the given specimen.
        */
        to exactly(wanted, ejector) {
            def original := current
            def [val, err] := ometaBase.anything(ejector)
            if (wanted == val) {
                return [val, err]
            } else {
                current := original
                ejector(current.error(term`expected(${wanted})`))
            }
        }

        /**
         Match a single character.
         */
        to char(ejector) {
            def [r, err] := ometaBase.anything(ejector)
            if (r !~ _ :char) {
                ejector(current.error(term`expected("a character")`))
            }
            return [r, err]
        }
        /**
         Consume input until a non-whitespace character is reached.
         */
        to spaces(ejector) {
            def space(e) {
              def [r, err] := ometaBase.char(e)
              if (r > ' ') {
                e(current.error(term`expected("whitespace")`))
              }
	      return [r, err]
            }
            return ometaBase._many(space)
        }

        /**
         Consume a given string plus any leading whitespace.
        */
        to token(ejector) {
          def [tok, _] := ometaBase.anything(ejector)
            def original := current
            ometaBase.spaces(ejector)
            var lastErr := null
            escape e {
                for ch in tok {
                  def [r, err] := ometaBase.exactly(ch, e)
                  lastErr := err
                }
            } catch err {
                current := original
                ejector(current.error(term`expected($tok)`))
            }
            return [tok, lastErr]
        }
        /**
         Match a single letter.
        */
        to letter(ejector) {
            def original := current
            def [x, err] := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                x == '_') {
              return [x, err]
            } else {
                current := original
                ejector(current.error(term`expected("letter")`))
            }
        }
        /**
         Match a single digit.
         */
        to digit(ejector) {
            def original := current
            def [x, e] := ometaBase.anything(ejector)
            if (x >= '0' && x <= '9') {
              return [x, e]
            } else {
                current := original
                ejector(current.error(term`expected("digit")`))
            }
        }
        /**
         Match a single alphanumeric character. (and '_').
        */
        to letterOrDigit(ejector) {
            def original := current
            def [x, e] := ometaBase.anything(ejector)
            if ((x >= 'A' && x <= 'Z') ||
                (x >= 'a' && x <= 'z') ||
                (x >= '0' && x <= '9') ||
                (x == '_')) {
                return [x, e]
            } else {
                current := original
                ejector(current.error(term`expected("letter or digit")`))
            }
        }

        to tokenBR(ejector) {
	  def [token, _] := ometaBase.anything(ejector)
	  def oldInput := current
	  escape e {
	    ometaBase.spaces(e)
	    for ch in token {
	      def r := ometaBase.exactly(ch, e)
	    }
	    def [v, brErr] := ometaBase._apply("br", [], e)
	    return [token, brErr]
	  } catch p {
	    current := oldInput
	    ejector(current.error(term`expected("token followed by line break or semicolon")`))
          }
        }

        to br(ejector) {}

        to considerError([expr, err]) {
            if (err != null) {
                currentError := joinErrors([err, currentError])
            }
            return [expr, currentError]
        }

        match [`rule_@name`, args] {
             E.call(ometaBase, name, args)
        }
    }
    return ometaBase
}
